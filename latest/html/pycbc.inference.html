

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pycbc.inference package &mdash; PyCBC 0c81ee documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PyCBC 0c81ee documentation" href="index.html"/>
        <link rel="up" title="pycbc package" href="pycbc.html"/>
        <link rel="next" title="pycbc.inject package" href="pycbc.inject.html"/>
        <link rel="prev" title="pycbc.filter package" href="pycbc.filter.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PyCBC
          

          
          </a>

          
            
            
              <div class="version">
                1.6.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_psd_estimation_workflow.html"><code class="docutils literal"><span class="pre">pycbc_make_psd_estimation_workflow</span></code>: A workflow generator for noise estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_coinc_search_workflow.html"><code class="docutils literal"><span class="pre">pycbc_make_coinc_search_workflow</span></code>: A workflow to search for gravitational waves</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_sngl_workflow.html"><code class="docutils literal"><span class="pre">pycbc_make_sngl_workflow</span></code>: A single-ifo detchar workflow generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow/pygrb.html"><code class="docutils literal"><span class="pre">pycbc_make_offline_grb_workflow</span></code>: A GRB triggered CBC analysis workflow generator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_inference_workflow.html"><code class="docutils literal"><span class="pre">pycbc_make_inference_workflow</span></code>: A parameter estimation workflow generator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tmpltbank.html">PyCBC template bank generation documentation (<code class="docutils literal"><span class="pre">pycbc.tmpltbank</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="inference.html">PyCBC inference documentation (<code class="docutils literal"><span class="pre">pycbc.inference</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="hwinj.html">Hardware injection waveform generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="banksim.html">Calculating the Effectualness (Fitting Factor) of Template Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="faithsim.html">Dag Generator for Doing Faithfulness Comparisons</a></li>
<li class="toctree-l1"><a class="reference internal" href="upload_to_gracedb.html">Uploading triggers to gracedb</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="waveform.html">Waveforms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documenting PyCBC code</a></li>
<li class="toctree-l1"><a class="reference internal" href="release.html">Creating Releases of PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="frame.html">Reading Gravitational-wave Frames (<code class="docutils literal"><span class="pre">pycbc.frame</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="formats/hdf_format.html">HDF files within the PyCBC workflow</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="workflow.html">Workflow: the inspiral analysis workflow generator (<code class="docutils literal"><span class="pre">pycbc.workflow</span></code>)</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">pycbc</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="pycbc.html">pycbc package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="pycbc.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="pycbc.events.html">pycbc.events package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.fft.html">pycbc.fft package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.filter.html">pycbc.filter package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">pycbc.inference package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.inject.html">pycbc.inject package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.io.html">pycbc.io package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.noise.html">pycbc.noise package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.psd.html">pycbc.psd package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.results.html">pycbc.results package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.tmpltbank.html">pycbc.tmpltbank package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.types.html">pycbc.types package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.vetoes.html">pycbc.vetoes package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.waveform.html">pycbc.waveform package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.workflow.html">pycbc.workflow package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.bin_utils">pycbc.bin_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.coordinates">pycbc.coordinates module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.detector">pycbc.detector module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.frame">pycbc.frame module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.future">pycbc.future module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.libutils">pycbc.libutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.opt">pycbc.opt module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.pnutils">pycbc.pnutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.rate">pycbc.rate module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.scheme">pycbc.scheme module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.sensitivity">pycbc.sensitivity module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.strain">pycbc.strain module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.version">pycbc.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.weave">pycbc.weave module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">PyCBC</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="modules.html">pycbc</a> &raquo;</li>
      
          <li><a href="pycbc.html">pycbc package</a> &raquo;</li>
      
    <li>pycbc.inference package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/pycbc.inference.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pycbc-inference-package">
<h1>pycbc.inference package<a class="headerlink" href="#pycbc-inference-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pycbc.inference.boundaries">
<span id="pycbc-inference-boundaries-module"></span><h2>pycbc.inference.boundaries module<a class="headerlink" href="#module-pycbc.inference.boundaries" title="Permalink to this headline">¶</a></h2>
<p>This modules provides utilities for manipulating parameter boundaries. Namely,
classes are offered that will map values to a specified domain using either
cyclic boundaries or reflected boundaries.</p>
<dl class="class">
<dt id="pycbc.inference.boundaries.Bounds">
<em class="property">class </em><code class="descclassname">pycbc.inference.boundaries.</code><code class="descname">Bounds</code><span class="sig-paren">(</span><em>min_bound=-inf</em>, <em>max_bound=inf</em>, <em>btype_min='closed'</em>, <em>btype_max='open'</em>, <em>cyclic=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#Bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.Bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Creates and stores bounds using the given values.</p>
<p>The type of boundaries used can be set using the <cite>btype_(min|max)</cite>
parameters. These arguments set what kind of boundary is used at the
minimum and maximum bounds. Specifically, if <cite>btype_min</cite> (<cite>btype_max</cite>) is
set to:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;open&#8221;: the minimum (maximum) boundary will be an instance of</li>
</ul>
<p><cite>OpenBound</cite>. This means that a value must be <cite>&gt;</cite> (<cite>&lt;</cite>) the bound
for it to be considered within the bounds.</p>
<ul class="simple">
<li>&#8220;closed&#8221;: the minimum (maximum) boundary will be an instance of</li>
</ul>
<p><cite>ClosedBound</cite>. This means that a value must be <cite>&gt;=</cite> (<cite>&lt;=</cite>) the bound
for it to be considered within the bounds.</p>
<ul class="simple">
<li>&#8220;reflected&#8221;: the minimum (maximum) boundary will be an isntance of</li>
</ul>
<p><cite>ReflectedBound</cite>. This means that a value will be reflected to the
right (left) if <cite>apply_conditions</cite> is used on the value. For more
details see <cite>apply_conditions</cite>.</p>
</div></blockquote>
<p>If the <cite>cyclic</cite> keyword is set to True, then <cite>apply_conditions</cite> will cause
values to be wrapped around to the minimum (maximum) bound if the value
is &gt; (&lt;=) the maximum (minimum) bound. For more details see
<cite>apply_conditions</cite>.</p>
<p>Values can be checked whether or not they occur within the bounds using
<cite>in</cite>; e.g., <cite>6 in bounds</cite>. This is done without applying any boundary
conditions. To apply conditions, then check whether the value is in
bounds, use the <cite>contains_conditioned</cite> method.</p>
<p>The default is for the minimum bound to be &#8220;closed&#8221; and the maximum bound
to be &#8220;open&#8221;, i.e., a right-open interval.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>min_bound</strong> : {-numpy.inf, float}</p>
<blockquote>
<div><p>The value of the lower bound. Default is <cite>-inf</cite>.</p>
</div></blockquote>
<p><strong>max_bound</strong> : {numpy.inf, float}</p>
<blockquote>
<div><p>The value of the upper bound. Default is <cite>inf</cite>.</p>
</div></blockquote>
<p><strong>btype_min</strong> : {&#8216;closed&#8217;, string}</p>
<blockquote>
<div><p>The type of the lower bound; options are &#8220;closed&#8221;, &#8220;open&#8221;, or
&#8220;reflected&#8221;. Default is &#8220;closed&#8221;.</p>
</div></blockquote>
<p><strong>btype_min</strong> : {&#8216;open&#8217;, string}</p>
<blockquote>
<div><p>The type of the lower bound; options are &#8220;closed&#8221;, &#8220;open&#8221;, or
&#8220;reflected&#8221;. Default is &#8220;open&#8221;.</p>
</div></blockquote>
<p><strong>cyclic</strong> : {False, bool}</p>
<blockquote class="last">
<div><p>Whether or not to make the bounds cyclic; default is False. If True,
both the minimum and maximum bounds must be finite.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create a right-open interval between -1 and 1 and test whether various
values are within them:
&gt;&gt;&gt; bounds = Bounds(-1., 1.)
&gt;&gt;&gt; -1 in bounds
True
&gt;&gt;&gt; 0 in bounds
True
&gt;&gt;&gt; 1 in bounds
False</p>
<p>Create an open interval between -1 and 1 and test the same values:
&gt;&gt;&gt; bounds = Bounds(-1, 1, btype_min=&#8221;open&#8221;)
&gt;&gt;&gt; -1 in bounds
False
&gt;&gt;&gt; 0 in bounds
True
&gt;&gt;&gt; 1 in bounds
False</p>
<p>Create cyclic bounds between -1 and 1 and plot the effect of conditioning
on points between -10 and 10:
&gt;&gt;&gt; bounds = Bounds(-1, 1, cyclic=True)
&gt;&gt;&gt; x = numpy.linspace(-10, 10, num=1000)
&gt;&gt;&gt; conditioned_x = bounds.apply_conditions(x)
&gt;&gt;&gt; fig = pyplot.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(x, x, c=&#8217;b&#8217;, lw=2, label=&#8217;input&#8217;)
&gt;&gt;&gt; ax.plot(conditioned_x, x, c=&#8217;r&#8217;, lw=1)
&gt;&gt;&gt; ax.vlines([-1., 1.], x.min(), x.max(), color=&#8217;k&#8217;, linestyle=&#8217;&#8211;&#8217;)
&gt;&gt;&gt; ax.set_title(&#8216;cyclic bounds between x=-1,1&#8217;)
&gt;&gt;&gt; fig.show()</p>
<p>Create a reflected bound at -1 and plot the effect of conditioning:
&gt;&gt;&gt; bounds = Bounds(-1, 1, btype_min=&#8217;reflected&#8217;)
&gt;&gt;&gt; x = numpy.linspace(-10, 10, num=1000)
&gt;&gt;&gt; conditioned_x = bounds.apply_conditions(x)
&gt;&gt;&gt; fig = pyplot.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(x, x, c=&#8217;b&#8217;, lw=2, label=&#8217;input&#8217;)
&gt;&gt;&gt; ax.plot(conditioned_x, x, c=&#8217;r&#8217;, lw=1)
&gt;&gt;&gt; ax.vlines([-1., 1.], x.min(), x.max(), color=&#8217;k&#8217;, linestyle=&#8217;&#8211;&#8217;)
&gt;&gt;&gt; ax.set_title(&#8216;reflected right at x=-1&#8217;)
&gt;&gt;&gt; fig.show()</p>
<p>Create a reflected bound at 1 and plot the effect of conditioning:
&gt;&gt;&gt; bounds = Bounds(-1, 1, btype_max=&#8217;reflected&#8217;)
&gt;&gt;&gt; x = numpy.linspace(-10, 10, num=1000)
&gt;&gt;&gt; conditioned_x = bounds.apply_conditions(x)
&gt;&gt;&gt; fig = pyplot.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(x, x, c=&#8217;b&#8217;, lw=2, label=&#8217;input&#8217;)
&gt;&gt;&gt; ax.plot(conditioned_x, x, c=&#8217;r&#8217;, lw=1)
&gt;&gt;&gt; ax.vlines([-1., 1.], x.min(), x.max(), color=&#8217;k&#8217;, linestyle=&#8217;&#8211;&#8217;)
&gt;&gt;&gt; ax.set_title(&#8216;reflected left at x=1&#8217;)
&gt;&gt;&gt; fig.show()</p>
<p>Create reflected bounds at -1 and 1 and plot the effect of conditioning:
&gt;&gt;&gt; bounds = Bounds(-1, 1, btype_min=&#8217;reflected&#8217;, btype_max=&#8217;reflected&#8217;)
&gt;&gt;&gt; x = numpy.linspace(-10, 10, num=1000)
&gt;&gt;&gt; conditioned_x = bounds.apply_conditions(x)
&gt;&gt;&gt; fig = pyplot.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(x, x, c=&#8217;b&#8217;, lw=2, label=&#8217;input&#8217;)
&gt;&gt;&gt; ax.plot(conditioned_x, x, c=&#8217;r&#8217;, lw=1)
&gt;&gt;&gt; ax.vlines([-1., 1.], x.min(), x.max(), color=&#8217;k&#8217;, linestyle=&#8217;&#8211;&#8217;)
&gt;&gt;&gt; ax.set_title(&#8216;reflected betewen x=-1,1&#8217;)
&gt;&gt;&gt; fig.show()</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>min</td>
<td>(_Bound instance) The minimum bound.</td>
</tr>
<tr class="row-even"><td>max</td>
<td>(_Bound instance) The maximum bound.</td>
</tr>
<tr class="row-odd"><td>cyclic</td>
<td>(bool) Whether the bounds are cyclic or not.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.boundaries.Bounds.apply_conditions">
<code class="descname">apply_conditions</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#Bounds.apply_conditions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.Bounds.apply_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies any boundary conditions to the given value.</p>
<p>The value is manipulated according based on the following conditions:</p>
<blockquote>
<div><ul class="simple">
<li>If <cite>self.cyclic</cite> is True then <cite>value</cite> is wrapped around to the</li>
</ul>
<p>minimum (maximum) bound if <cite>value</cite> is <cite>&gt;= self.max</cite> (<cite>&lt; self.min</cite>)
bound. For example, if the minimum and maximum bounds are <cite>0, 2*pi</cite>
and <cite>value = 5*pi</cite>, then the returned value will be <cite>pi</cite>.</p>
<ul class="simple">
<li>If <cite>self.min</cite> is a reflected boundary then <cite>value</cite> will be</li>
</ul>
<p>reflected to the right if it is <cite>&lt; self.min</cite>. For example, if
<cite>self.min = 10</cite> and <cite>value = 3</cite>, then the returned value will be
17.</p>
<ul class="simple">
<li>If <cite>self.max</cite> is a reflected boundary then <cite>value</cite> will be</li>
</ul>
<p>reflected to the left if it is <cite>&gt; self.max</cite>. For example, if
<cite>self.max = 20</cite> and <cite>value = 27</cite>, then the returned value will be
13.</p>
<ul class="simple">
<li>If <cite>self.min</cite> and <cite>self.max</cite> are both reflected boundaries, then</li>
</ul>
<p><cite>value</cite> will be reflected between the two boundaries until it
falls within the bounds. The first reflection occurs off of the
maximum boundary. For example, if <cite>self.min = 10</cite>, <cite>self.max =
20</cite>, and <cite>value = 42</cite>, the returned value will be 18 ( the first
reflection yields -2, the second 22, and the last 18).</p>
<ul class="simple">
<li>If neither bounds are reflected and cyclic is False, then the</li>
</ul>
<p>value is just returned as-is.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : float</p>
<blockquote>
<div><p>The value to apply the conditions to.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>The value after the conditions are applied; see above for details.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.boundaries.Bounds.contains_conditioned">
<code class="descname">contains_conditioned</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#Bounds.contains_conditioned"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.Bounds.contains_conditioned" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs <cite>apply_conditions</cite> on the given value before testing whether it
is in bounds. Note that if <cite>cyclic</cite> is True, or both bounds
are reflected, than this will always return True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : float</p>
<blockquote>
<div><p>The value to test.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">bool</p>
<blockquote class="last">
<div><p>Whether or not the value is within the bounds after the boundary
conditions are applied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.boundaries.Bounds.cyclic">
<code class="descname">cyclic</code><a class="headerlink" href="#pycbc.inference.boundaries.Bounds.cyclic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.boundaries.Bounds.max">
<code class="descname">max</code><a class="headerlink" href="#pycbc.inference.boundaries.Bounds.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.boundaries.Bounds.min">
<code class="descname">min</code><a class="headerlink" href="#pycbc.inference.boundaries.Bounds.min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.boundaries.ClosedBound">
<em class="property">class </em><code class="descclassname">pycbc.inference.boundaries.</code><code class="descname">ClosedBound</code><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#ClosedBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.ClosedBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.boundaries._Bound</span></code></p>
<p>Sets larger and smaller functions to be <cite>&gt;=</cite> and <cite>&lt;=</cite>, respectively.</p>
<dl class="method">
<dt id="pycbc.inference.boundaries.ClosedBound.larger">
<code class="descname">larger</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#ClosedBound.larger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.ClosedBound.larger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.boundaries.ClosedBound.name">
<code class="descname">name</code><em class="property"> = 'closed'</em><a class="headerlink" href="#pycbc.inference.boundaries.ClosedBound.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.boundaries.ClosedBound.smaller">
<code class="descname">smaller</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#ClosedBound.smaller"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.ClosedBound.smaller" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.boundaries.OpenBound">
<em class="property">class </em><code class="descclassname">pycbc.inference.boundaries.</code><code class="descname">OpenBound</code><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#OpenBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.OpenBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.boundaries._Bound</span></code></p>
<p>Sets larger and smaller functions to be <cite>&gt;</cite> and <cite>&lt;</cite>, respectively.</p>
<dl class="method">
<dt id="pycbc.inference.boundaries.OpenBound.larger">
<code class="descname">larger</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#OpenBound.larger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.OpenBound.larger" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if <cite>other</cite> is <cite>&gt;</cite>, False otherwise</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.boundaries.OpenBound.name">
<code class="descname">name</code><em class="property"> = 'open'</em><a class="headerlink" href="#pycbc.inference.boundaries.OpenBound.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.boundaries.OpenBound.smaller">
<code class="descname">smaller</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#OpenBound.smaller"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.OpenBound.smaller" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if <cite>other</cite> is <cite>&lt;</cite>, False otherwise.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.boundaries.ReflectedBound">
<em class="property">class </em><code class="descclassname">pycbc.inference.boundaries.</code><code class="descname">ReflectedBound</code><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#ReflectedBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.ReflectedBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.boundaries.ClosedBound" title="pycbc.inference.boundaries.ClosedBound"><code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.boundaries.ClosedBound</span></code></a></p>
<p>Inherits from <cite>ClosedBound</cite>, adding reflection functions.</p>
<dl class="attribute">
<dt id="pycbc.inference.boundaries.ReflectedBound.name">
<code class="descname">name</code><em class="property"> = 'reflected'</em><a class="headerlink" href="#pycbc.inference.boundaries.ReflectedBound.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.boundaries.ReflectedBound.reflect">
<code class="descname">reflect</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#ReflectedBound.reflect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.ReflectedBound.reflect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.boundaries.ReflectedBound.reflect_left">
<code class="descname">reflect_left</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#ReflectedBound.reflect_left"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.ReflectedBound.reflect_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Only reflects the value if is &gt; self.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.boundaries.ReflectedBound.reflect_right">
<code class="descname">reflect_right</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#ReflectedBound.reflect_right"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.ReflectedBound.reflect_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Only reflects the value if is &lt; self.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.inference.boundaries.apply_cyclic">
<code class="descclassname">pycbc.inference.boundaries.</code><code class="descname">apply_cyclic</code><span class="sig-paren">(</span><em>value</em>, <em>bounds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#apply_cyclic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.apply_cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a value, applies cyclic boundary conditions between the minimum
and maximum bounds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : float</p>
<blockquote>
<div><p>The value to apply the cyclic conditions to.</p>
</div></blockquote>
<p><strong>bounds</strong> : Bounds instance</p>
<blockquote>
<div><p>Boundaries to use for applying cyclic conditions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>The value after the cyclic bounds are applied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.boundaries.reflect_well">
<code class="descclassname">pycbc.inference.boundaries.</code><code class="descname">reflect_well</code><span class="sig-paren">(</span><em>value</em>, <em>bounds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/boundaries.html#reflect_well"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.boundaries.reflect_well" title="Permalink to this definition">¶</a></dt>
<dd><p>Given some boundaries, reflects the value until it falls within both
boundaries. This is done iteratively, reflecting left off of the
<cite>boundaries.max</cite>, then right off of the <cite>boundaries.min</cite>, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : float</p>
<blockquote>
<div><p>The value to apply the reflected boundaries to.</p>
</div></blockquote>
<p><strong>bounds</strong> : Bounds instance</p>
<blockquote>
<div><p>Boundaries to reflect between. Both <cite>bounds.min</cite> and <cite>bounds.max</cite> must
be instances of <cite>ReflectedBound</cite>, otherwise an AttributeError is
raised.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>The value after being reflected between the two bounds.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.distributions">
<span id="pycbc-inference-distributions-module"></span><h2>pycbc.inference.distributions module<a class="headerlink" href="#module-pycbc.inference.distributions" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for evaluating the prior
for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.distributions.CosAngle">
<em class="property">class </em><code class="descclassname">pycbc.inference.distributions.</code><code class="descname">CosAngle</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#CosAngle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.CosAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.distributions.SinAngle" title="pycbc.inference.distributions.SinAngle"><code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.distributions.SinAngle</span></code></a></p>
<p>A cosine distribution. This is the same thing as a sine distribution,
but with the domain shifted to <cite>[-pi/2, pi/2]</cite>. See SinAngle for more
details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**params :</strong></p>
<blockquote class="last">
<div><p>The keyword arguments should provide the names of parameters and
(optionally) their corresponding bounds, as either
<cite>boundaries.Bounds</cite> instances or tuples. The bounds must be
in [-0.5, 0.5]. These are converted to radians for storage.
None may also be passed; in that case, the domain bounds will be used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>params</td>
<td>(list of strings) The list of parameter names.</td>
</tr>
<tr class="row-even"><td>bounds</td>
<td>(dict) A dictionary of the parameter names and their bounds, in radians.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pycbc.inference.distributions.CosAngle.name">
<code class="descname">name</code><em class="property"> = 'cos_angle'</em><a class="headerlink" href="#pycbc.inference.distributions.CosAngle.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.distributions.FromFile">
<em class="property">class </em><code class="descclassname">pycbc.inference.distributions.</code><code class="descname">FromFile</code><span class="sig-paren">(</span><em>file_name=None</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#FromFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.FromFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.distributions._BoundedDist</span></code></p>
<p>A distribution that reads the values of the parameter(s) from an hdf
file, computes the kde to construct the pdf, and draws random variables
from it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_name</strong> : str</p>
<blockquote>
<div><p>The path to an hdf file containing the values of the parameters that
want to be used to construct the distribution. Each parameter should
be a separate dataset in the hdf file, and all datasets should have
the same size. For example, to give a prior for mass1 and mass2 from
file f, f[&#8216;mass1&#8217;] and f[&#8216;mass2&#8217;] contain the n values for each
parameter.</p>
</div></blockquote>
<p><strong>**params :</strong></p>
<blockquote class="last">
<div><p>The keyword arguments should provide the names of the parameters to be
read from the file and (optionally) their bounds. If no parameters are
provided, it will use all the parameters found in the file. To provide
bounds, specify e.g. mass1=[10,100]. Otherwise, mass1=None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>name</td>
<td>(&#8216;fromfile&#8217;) The name of the distribution.</td>
</tr>
<tr class="row-even"><td>file_name</td>
<td>(str) The path to the file containing values for the parameter(s).</td>
</tr>
<tr class="row-odd"><td>params</td>
<td>(list) Parameters read from file.</td>
</tr>
<tr class="row-even"><td>norm</td>
<td>(float) The normalization of the multi-dimensional pdf.</td>
</tr>
<tr class="row-odd"><td>lognorm</td>
<td>(float) The log of the normalization.</td>
</tr>
<tr class="row-even"><td>kde :</td>
<td>The kde obtained from the values in the file.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pycbc.inference.distributions.FromFile.file_name">
<code class="descname">file_name</code><a class="headerlink" href="#pycbc.inference.distributions.FromFile.file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.distributions.FromFile.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em>, <em>variable_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#FromFile.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.FromFile.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a distribution based on a configuration file. The parameters
for the distribution are retrieved from the section titled
&#8220;[<cite>section</cite>-<cite>variable_args</cite>]&#8221; in the config file.</p>
<p>The file to construct the distribution from must be provided by setting
<cite>file_name</cite>. Boundary arguments can be provided in the same way as
described in <cite>get_param_bounds_from_config</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cp</strong> : pycbc.workflow.WorkflowConfigParser</p>
<blockquote>
<div><p>A parsed configuration file that contains the distribution
options.</p>
</div></blockquote>
<p><strong>section</strong> : str</p>
<blockquote>
<div><p>Name of the section in the configuration file.</p>
</div></blockquote>
<p><strong>variable_args</strong> : str</p>
<blockquote>
<div><p>The names of the parameters for this distribution, separated by
<cite>prior.VARARGS_DELIM</cite>. These must appear in the &#8220;tag&#8221; part
of the section header.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Uniform</p>
<blockquote class="last">
<div><p>A distribution instance from the pycbc.inference.prior module.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.distributions.FromFile.get_kde_from_file">
<em class="property">static </em><code class="descname">get_kde_from_file</code><span class="sig-paren">(</span><em>params_file</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#FromFile.get_kde_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.FromFile.get_kde_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the values of one or more parameters from an hdf file and
computes the kernel density estimate (kde).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params_file</strong> : str</p>
<blockquote>
<div><p>The hdf file that contains the values of the parameters.</p>
</div></blockquote>
<p><strong>params</strong> : {None, list}</p>
<blockquote>
<div><p>If provided, will just use the values for the given parameter.
Otherwise, uses the values for each parameter in the file.</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p><strong>values</strong></p>
<blockquote>
<div><p>Array with the values of the parameters.</p>
</div></blockquote>
<p><strong>kde</strong></p>
<blockquote class="last">
<div><p>The kde from the parameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.FromFile.kde">
<code class="descname">kde</code><a class="headerlink" href="#pycbc.inference.distributions.FromFile.kde" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.FromFile.lognorm">
<code class="descname">lognorm</code><a class="headerlink" href="#pycbc.inference.distributions.FromFile.lognorm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.FromFile.name">
<code class="descname">name</code><em class="property"> = 'fromfile'</em><a class="headerlink" href="#pycbc.inference.distributions.FromFile.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.FromFile.norm">
<code class="descname">norm</code><a class="headerlink" href="#pycbc.inference.distributions.FromFile.norm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.FromFile.params">
<code class="descname">params</code><a class="headerlink" href="#pycbc.inference.distributions.FromFile.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.distributions.FromFile.rvs">
<code class="descname">rvs</code><span class="sig-paren">(</span><em>size=1</em>, <em>param=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#FromFile.rvs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.FromFile.rvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a set of random values drawn from the kde.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : {1, int}</p>
<blockquote>
<div><p>The number of values to generate; default is 1.</p>
</div></blockquote>
<p><strong>param</strong> : {None, string}</p>
<blockquote>
<div><p>If provided, will just return values for the given parameter.
Otherwise, returns random values for each parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">structured array</p>
<blockquote class="last">
<div><p>The random values in a numpy structured array. If a param was
specified, the array will only have an element corresponding to the
given parameter. Otherwise, the array will have an element for each
parameter in self&#8217;s params.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.distributions.Gaussian">
<em class="property">class </em><code class="descclassname">pycbc.inference.distributions.</code><code class="descname">Gaussian</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#Gaussian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.distributions._BoundedDist</span></code></p>
<p>A Gaussian distribution on the given parameters; the parameters are
independent of each other.</p>
<p>Bounds can be provided on each parameter, in which case the distribution
will be a truncated Gaussian distribution.  The PDF of a truncated
Gaussian distribution is given by:</p>
<img src="_images/mathmpl/math-c0052715b5.png" class="center" /><p>where <img src="_images/mathmpl/math-3488de1d0a.png" style="position: relative; bottom: -7px"/> is the mean, <img src="_images/mathmpl/math-54bf156f7e.png" style="position: relative; bottom: -3px"/> is the variance,
<img src="_images/mathmpl/math-9f09167892.png" style="position: relative; bottom: -7px"/> are the bounds, and <img src="_images/mathmpl/math-cebfe4186d.png" style="position: relative; bottom: -3px"/> is the cumulative distribution
of an unbounded normal distribution, given by:</p>
<img src="_images/mathmpl/math-7f1b9edd06.png" class="center" /><p>Note that if <img src="_images/mathmpl/math-90518b2dfa.png" style="position: relative; bottom: -8px"/>, this reduces to a standard
Gaussian distribution.</p>
<p>Instances of this class can be called like a function. By default, logpdf
will be called, but this can be changed by setting the class&#8217;s __call__
method to its pdf method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**params :</strong></p>
<blockquote class="last">
<div><p>The keyword arguments should provide the names of parameters and
(optionally) some bounds, as either a tuple or a
<cite>boundaries.Bounds</cite> instance. The mean and variance of each
parameter can be provided by additional keyword arguments that have
<cite>_mean</cite> and <cite>_var</cite> adding to the parameter name. For example,
<cite>foo=(-2,10), foo_mean=3, foo_var=2</cite> would create a truncated Gaussian
with mean 3 and variance 2, bounded between <img src="_images/mathmpl/math-216cf430b1.png" style="position: relative; bottom: -8px"/>. If no
mean or variance is provided, the distribution will have 0 mean and
unit variance. If None is provided for the bounds, the distribution
will be a normal, unbounded Gaussian (equivalent to setting the bounds
to <cite>[-inf, inf)</cite>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="pycbc.inference.distributions.Gaussian.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em>, <em>variable_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#Gaussian.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.Gaussian.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Gaussian distribution based on a configuration file. The
parameters for the distribution are retrieved from the section titled
&#8220;[<cite>section</cite>-<cite>variable_args</cite>]&#8221; in the config file.</p>
<p>Boundary arguments should be provided in the same way as described in
<cite>get_param_bounds_from_config</cite>. In addition, the mean and variance of
each parameter can be specified by setting <cite>{param}_mean</cite> and
<cite>{param}_var</cite>, respectively. For example, the following would create a
truncated Gaussian distribution between 0 and 6.28 for a parameter
called <cite>phi</cite> with mean 3.14 and variance 0.5 that is cyclic:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cp</strong> : pycbc.workflow.WorkflowConfigParser</p>
<blockquote>
<div><p>A parsed configuration file that contains the distribution
options.</p>
</div></blockquote>
<p><strong>section</strong> : str</p>
<blockquote>
<div><p>Name of the section in the configuration file.</p>
</div></blockquote>
<p><strong>variable_args</strong> : str</p>
<blockquote>
<div><p>The names of the parameters for this distribution, separated by
<cite>prior.VARARGS_DELIM</cite>. These must appear in the &#8220;tag&#8221; part
of the section header.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Gaussain</p>
<blockquote class="last">
<div><p>A distribution instance from the pycbc.inference.prior module.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.Gaussian.mean">
<code class="descname">mean</code><a class="headerlink" href="#pycbc.inference.distributions.Gaussian.mean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.Gaussian.name">
<code class="descname">name</code><em class="property"> = 'gaussian'</em><a class="headerlink" href="#pycbc.inference.distributions.Gaussian.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.distributions.Gaussian.rvs">
<code class="descname">rvs</code><span class="sig-paren">(</span><em>size=1</em>, <em>param=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#Gaussian.rvs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.Gaussian.rvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a set of random values drawn from this distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : {1, int}</p>
<blockquote>
<div><p>The number of values to generate; default is 1.</p>
</div></blockquote>
<p><strong>param</strong> : {None, string}</p>
<blockquote>
<div><p>If provided, will just return values for the given parameter.
Otherwise, returns random values for each parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">structured array</p>
<blockquote class="last">
<div><p>The random values in a numpy structured array. If a param was
specified, the array will only have an element corresponding to the
given parameter. Otherwise, the array will have an element for each
parameter in self&#8217;s params.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.Gaussian.var">
<code class="descname">var</code><a class="headerlink" href="#pycbc.inference.distributions.Gaussian.var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.distributions.SinAngle">
<em class="property">class </em><code class="descclassname">pycbc.inference.distributions.</code><code class="descname">SinAngle</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#SinAngle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.SinAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.distributions.UniformAngle" title="pycbc.inference.distributions.UniformAngle"><code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.distributions.UniformAngle</span></code></a></p>
<p>A sine distribution; the pdf of each parameter <cite>theta</cite> is given by:</p>
<dl class="docutils">
<dt>..math::</dt>
<dd>p(theta) = frac{sin theta}{costheta_0 - costheta_1}, theta_0 leq theta &lt; theta_1,</dd>
</dl>
<p>and 0 otherwise. Here, <img src="_images/mathmpl/math-af7ae95364.png" style="position: relative; bottom: -7px"/> are the bounds of the
parameter.</p>
<p>The domain of this distribution is <cite>[0, pi]</cite>. This is accomplished by
putting hard boundaries at <cite>[0, pi]</cite>. Bounds may be provided to further
limit the range for which the pdf has support.  As with <cite>UniformAngle</cite>,
these are initizliaed as multiples of pi, while the stored bounds are in
radians.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**params :</strong></p>
<blockquote class="last">
<div><p>The keyword arguments should provide the names of parameters and
(optionally) their corresponding bounds, as either
<cite>boundaries.Bounds</cite> instances or tuples. The bounds must be
in [0,1]. These are converted to radians for storage. None may also
be passed; in that case, the domain bounds will be used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>params</td>
<td>(list of strings) The list of parameter names.</td>
</tr>
<tr class="row-even"><td>bounds</td>
<td>(dict) A dictionary of the parameter names and their bounds, in radians.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pycbc.inference.distributions.SinAngle.name">
<code class="descname">name</code><em class="property"> = 'sin_angle'</em><a class="headerlink" href="#pycbc.inference.distributions.SinAngle.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.distributions.SinAngle.rvs">
<code class="descname">rvs</code><span class="sig-paren">(</span><em>size=1</em>, <em>param=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#SinAngle.rvs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.SinAngle.rvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a set of random values drawn from this distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : {1, int}</p>
<blockquote>
<div><p>The number of values to generate; default is 1.</p>
</div></blockquote>
<p><strong>param</strong> : {None, string}</p>
<blockquote>
<div><p>If provided, will just return values for the given parameter.
Otherwise, returns random values for each parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">structured array</p>
<blockquote class="last">
<div><p>The random values in a numpy structured array. If a param was
specified, the array will only have an element corresponding to the
given parameter. Otherwise, the array will have an element for each
parameter in self&#8217;s params.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.distributions.Uniform">
<em class="property">class </em><code class="descclassname">pycbc.inference.distributions.</code><code class="descname">Uniform</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#Uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.Uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.distributions._BoundedDist</span></code></p>
<p>A uniform distribution on the given parameters. The parameters are
independent of each other. Instances of this class can be called like
a function. By default, logpdf will be called, but this can be changed
by setting the class&#8217;s __call__ method to its pdf method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**params :</strong></p>
<blockquote class="last">
<div><p>The keyword arguments should provide the names of parameters and their
corresponding bounds, as either tuples or a <cite>boundaries.Bounds</cite>
instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>params</td>
<td>(list of strings) The list of parameter names.</td>
</tr>
<tr class="row-even"><td>bounds</td>
<td>(dict) A dictionary of the parameter names and their bounds.</td>
</tr>
<tr class="row-odd"><td>norm</td>
<td>(float) The normalization of the multi-dimensional pdf.</td>
</tr>
<tr class="row-even"><td>lognorm</td>
<td>(float) The log of the normalization.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="pycbc.inference.distributions.Uniform.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em>, <em>variable_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#Uniform.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.Uniform.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a distribution based on a configuration file. The parameters
for the distribution are retrieved from the section titled
&#8220;[<cite>section</cite>-<cite>variable_args</cite>]&#8221; in the config file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cp</strong> : pycbc.workflow.WorkflowConfigParser</p>
<blockquote>
<div><p>A parsed configuration file that contains the distribution
options.</p>
</div></blockquote>
<p><strong>section</strong> : str</p>
<blockquote>
<div><p>Name of the section in the configuration file.</p>
</div></blockquote>
<p><strong>variable_args</strong> : str</p>
<blockquote>
<div><p>The names of the parameters for this distribution, separated by
<cite>prior.VARARGS_DELIM</cite>. These must appear in the &#8220;tag&#8221; part
of the section header.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Uniform</p>
<blockquote class="last">
<div><p>A distribution instance from the pycbc.inference.prior module.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.Uniform.lognorm">
<code class="descname">lognorm</code><a class="headerlink" href="#pycbc.inference.distributions.Uniform.lognorm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.Uniform.name">
<code class="descname">name</code><em class="property"> = 'uniform'</em><a class="headerlink" href="#pycbc.inference.distributions.Uniform.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.Uniform.norm">
<code class="descname">norm</code><a class="headerlink" href="#pycbc.inference.distributions.Uniform.norm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.distributions.Uniform.rvs">
<code class="descname">rvs</code><span class="sig-paren">(</span><em>size=1</em>, <em>param=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#Uniform.rvs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.Uniform.rvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a set of random values drawn from this distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : {1, int}</p>
<blockquote>
<div><p>The number of values to generate; default is 1.</p>
</div></blockquote>
<p><strong>param</strong> : {None, string}</p>
<blockquote>
<div><p>If provided, will just return values for the given parameter.
Otherwise, returns random values for each parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">structured array</p>
<blockquote class="last">
<div><p>The random values in a numpy structured array. If a param was
specified, the array will only have an element corresponding to the
given parameter. Otherwise, the array will have an element for each
parameter in self&#8217;s params.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.distributions.UniformAngle">
<em class="property">class </em><code class="descclassname">pycbc.inference.distributions.</code><code class="descname">UniformAngle</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#UniformAngle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.UniformAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.distributions.Uniform" title="pycbc.inference.distributions.Uniform"><code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.distributions.Uniform</span></code></a></p>
<p>A uniform distribution in which the dependent variable is cyclic between
<cite>[0,2pi)</cite>.</p>
<p>Bounds may be provided to limit the range for which the pdf has support.
If provided, the parameter bounds are initialized as multiples of pi,
while the stored bounds are in radians.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**params :</strong></p>
<blockquote class="last">
<div><p>The keyword arguments should provide the names of parameters and
(optionally) their corresponding bounds, as either
<cite>boundaries.Bounds</cite> instances or tuples. The bounds must be
in [0,2). These are converted to radians for storage. None may also
be passed; in that case, the domain bounds will be used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>params</td>
<td>(list of strings) The list of parameter names.</td>
</tr>
<tr class="row-even"><td>bounds</td>
<td>(dict) A dictionary of the parameter names and their bounds, in radians.</td>
</tr>
<tr class="row-odd"><td>For more information, see Uniform.</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.distributions.UniformAngle.apply_boundary_conditions">
<code class="descname">apply_boundary_conditions</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#UniformAngle.apply_boundary_conditions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.UniformAngle.apply_boundary_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps values to be in [0, 2pi) (the domain) first, before applying
any additional boundary conditions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs :</strong></p>
<blockquote>
<div><p>The keyword args should be the name of a parameter and value to
apply its boundary conditions to. The arguments need not include
all of the parameters in self.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>A dictionary of the parameter names and the conditioned values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.distributions.UniformAngle.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em>, <em>variable_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#UniformAngle.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.UniformAngle.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a distribution based on a configuration file. The parameters
for the distribution are retrieved from the section titled
&#8220;[<cite>section</cite>-<cite>variable_args</cite>]&#8221; in the config file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cp</strong> : pycbc.workflow.WorkflowConfigParser</p>
<blockquote>
<div><p>A parsed configuration file that contains the distribution
options.</p>
</div></blockquote>
<p><strong>section</strong> : str</p>
<blockquote>
<div><p>Name of the section in the configuration file.</p>
</div></blockquote>
<p><strong>variable_args</strong> : str</p>
<blockquote>
<div><p>The names of the parameters for this distribution, separated by
<cite>prior.VARARGS_DELIM</cite>. These must appear in the &#8220;tag&#8221; part
of the section header.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">UniformAngle</p>
<blockquote class="last">
<div><p>A distribution instance from the pycbc.inference.prior module.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.UniformAngle.name">
<code class="descname">name</code><em class="property"> = 'uniform_angle'</em><a class="headerlink" href="#pycbc.inference.distributions.UniformAngle.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.distributions.UniformSky">
<em class="property">class </em><code class="descclassname">pycbc.inference.distributions.</code><code class="descname">UniformSky</code><span class="sig-paren">(</span><em>polar_angle='theta'</em>, <em>azimuthal_angle='phi'</em>, <em>polar_bounds=None</em>, <em>azimuthal_bounds=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#UniformSky"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.UniformSky" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.distributions.UniformSolidAngle" title="pycbc.inference.distributions.UniformSolidAngle"><code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.distributions.UniformSolidAngle</span></code></a></p>
<p>A distribution that is uniform on the sky. This is the same as
UniformSolidAngle, except that the polar angle varies from pi/2 (the north
pole) to -pi/2 (the south pole) instead of 0 to pi. Also, the default
names are &#8220;dec&#8221; (declination) for the polar angle and &#8220;ra&#8221; (right
ascension) for the azimuthal angle, instead of &#8220;theta&#8221; and &#8220;phi&#8221;.</p>
<dl class="attribute">
<dt id="pycbc.inference.distributions.UniformSky.name">
<code class="descname">name</code><em class="property"> = 'uniform_sky'</em><a class="headerlink" href="#pycbc.inference.distributions.UniformSky.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.distributions.UniformSolidAngle">
<em class="property">class </em><code class="descclassname">pycbc.inference.distributions.</code><code class="descname">UniformSolidAngle</code><span class="sig-paren">(</span><em>polar_angle='theta'</em>, <em>azimuthal_angle='phi'</em>, <em>polar_bounds=None</em>, <em>azimuthal_bounds=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#UniformSolidAngle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.UniformSolidAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.distributions._BoundedDist</span></code></p>
<p>A distribution that is uniform in the solid angle of a sphere. The names
of the two angluar parameters can be specified on initalization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>polar_angle</strong> : {&#8216;theta&#8217;, str}</p>
<blockquote>
<div><p>The name of the polar angle.</p>
</div></blockquote>
<p><strong>azimuthal_angle</strong> : {&#8216;phi&#8217;, str}</p>
<blockquote>
<div><p>The name of the azimuthal angle.</p>
</div></blockquote>
<p><strong>polar_bounds</strong> : {None, (min, max)}</p>
<blockquote>
<div><p>Limit the polar angle to the given bounds. If None provided, the polar
angle will vary from 0 (the north pole) to pi (the south pole). The
bounds should be specified as factors of pi. For example, to limit
the distribution to the northern hemisphere, set
<cite>polar_bounds=(0,0.5)</cite>.</p>
</div></blockquote>
<p><strong>azimuthal_bounds</strong> : {None, (min, max)}</p>
<blockquote class="last">
<div><p>Limit the azimuthal angle to the given bounds. If None provided, the
azimuthal angle will vary from 0 to 2pi. The
bounds should be specified as factors of pi. For example, to limit
the distribution to the one hemisphere, set <cite>azimuthal_bounds=(0,1)</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>bounds</td>
<td>(dict) The bounds on each angle. The keys are the names of the polar and azimuthal angles, the values are the minimum and maximum of each, in radians. For example, if the distribution was initialized with <cite>polar_angle=&#8217;theta&#8217;, polar_bounds=(0,0.5)</cite> then the bounds will have <cite>&#8216;theta&#8217;: 0, 1.5707963267948966</cite> as an entry.</td>
</tr>
<tr class="row-even"><td>params</td>
<td>(list) The names of the polar and azimuthal angles.</td>
</tr>
<tr class="row-odd"><td>polar_angle</td>
<td>(str) The name of the polar angle.</td>
</tr>
<tr class="row-even"><td>azimuthal_angle</td>
<td>(str) The name of the azimuthal angle.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.distributions.UniformSolidAngle.apply_boundary_conditions">
<code class="descname">apply_boundary_conditions</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#UniformSolidAngle.apply_boundary_conditions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.UniformSolidAngle.apply_boundary_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the given values to be within the domain of the azimuthal and
polar angles, before applying any other boundary conditions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs :</strong></p>
<blockquote>
<div><p>The keyword args must include values for both the azimuthal and
polar angle, using the names they were initilialized with. For
example, if <cite>polar_angle=&#8217;theta&#8217;</cite> and <cite>azimuthal_angle=`phi</cite>, then
the keyword args must be <cite>theta={val1}, phi={val2}</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>A dictionary of the parameter names and the conditioned values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.UniformSolidAngle.azimuthal_angle">
<code class="descname">azimuthal_angle</code><a class="headerlink" href="#pycbc.inference.distributions.UniformSolidAngle.azimuthal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.distributions.UniformSolidAngle.from_config">
<em class="property">classmethod </em><code class="descname">from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em>, <em>variable_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#UniformSolidAngle.from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.UniformSolidAngle.from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a distribution based on a configuration file. The section
must have the names of the polar and azimuthal angles in the tag part
of the section header. For example:</p>
<p>If nothing else is provided, the default names and bounds of the polar
and azimuthal angles will be used. To specify a different name for
each angle, set the <cite>polar-angle</cite> and <cite>azimuthal-angle</cite> attributes. For
example:</p>
<dl class="docutils">
<dt>..code-block::</dt>
<dd>[prior-foo+bar]
name = uniform_solidangle
polar-angle = foo
azimuthal-angle = bar</dd>
</dl>
<p>Note that the names of the variable args in the tag part of the section
name must match the names of the polar and azimuthal angles.</p>
<p>Bounds may also be specified for each angle, as factors of pi. For
example:</p>
<p>This will return a distribution that is uniform in the upper
hemisphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cp</strong> : ConfigParser instance</p>
<blockquote>
<div><p>The config file.</p>
</div></blockquote>
<p><strong>section</strong> : str</p>
<blockquote>
<div><p>The name of the section.</p>
</div></blockquote>
<p><strong>variable_args</strong> : str</p>
<blockquote>
<div><p>The names of the parameters for this distribution, separated by
<cite>prior.VARARGS_DELIM</cite>. These must appear in the &#8220;tag&#8221; part
of the section header.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">UniformSolidAngle</p>
<blockquote class="last">
<div><p>A distribution instance from the pycbc.inference.prior module.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.UniformSolidAngle.name">
<code class="descname">name</code><em class="property"> = 'uniform_solidangle'</em><a class="headerlink" href="#pycbc.inference.distributions.UniformSolidAngle.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.distributions.UniformSolidAngle.polar_angle">
<code class="descname">polar_angle</code><a class="headerlink" href="#pycbc.inference.distributions.UniformSolidAngle.polar_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.distributions.UniformSolidAngle.rvs">
<code class="descname">rvs</code><span class="sig-paren">(</span><em>size=1</em>, <em>param=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#UniformSolidAngle.rvs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.UniformSolidAngle.rvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a set of random values drawn from this distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : {1, int}</p>
<blockquote>
<div><p>The number of values to generate; default is 1.</p>
</div></blockquote>
<p><strong>param</strong> : {None, string}</p>
<blockquote>
<div><p>If provided, will just return values for the given parameter.
Otherwise, returns random values for each parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">structured array</p>
<blockquote class="last">
<div><p>The random values in a numpy structured array. If a param was
specified, the array will only have an element corresponding to the
given parameter. Otherwise, the array will have an element for each
parameter in self&#8217;s params.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.inference.distributions.get_param_bounds_from_config">
<code class="descclassname">pycbc.inference.distributions.</code><code class="descname">get_param_bounds_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section</em>, <em>tag</em>, <em>param</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#get_param_bounds_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.get_param_bounds_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets bounds for the given parameter from a section in a config file.</p>
<p>Minimum and maximum values for bounds are specified by adding
<cite>min-{param}</cite> and <cite>max-{param}</cite> options, where <cite>{param}</cite> is the name of
the parameter. The types of boundary (open, closed, or reflected) to create
may also be specified by adding options <cite>btype-min-{param}</cite> and
<cite>btype-max-{param}</cite>. Cyclic conditions can be adding option
<cite>cyclic-{param}</cite>. If no <cite>btype</cite> arguments are provided, the
left bound will be closed and the right open.</p>
<p>For example, the following will create right-open bounds for parameter
<cite>foo</cite>:</p>
<p>This would make the boundaries cyclic:</p>
<p>For more details on boundary types and their meaning, see
<cite>boundaries.Bounds</cite>.</p>
<p>If the parameter is not found in the section will just return None (in
this case, all <cite>btype</cite> and <cite>cyclic</cite> arguments are ignored for that
parameter).  If bounds are specified, both a minimum and maximum must be
provided, else a Value or Type Error will be raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cp</strong> : ConfigParser instance</p>
<blockquote>
<div><p>The config file.</p>
</div></blockquote>
<p><strong>section</strong> : str</p>
<blockquote>
<div><p>The name of the section.</p>
</div></blockquote>
<p><strong>tag</strong> : str</p>
<blockquote>
<div><p>Any tag in the section name. The full section name searched for in
the config file is <cite>{section}(-{tag})</cite>.</p>
</div></blockquote>
<p><strong>param</strong> : str</p>
<blockquote>
<div><p>The name of the parameter to retrieve bounds for.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bounds</strong> : {Bounds instance | None}</p>
<blockquote class="last">
<div><p>If bounds were provided, a <cite>boundaries.Bounds</cite> instance
representing the bounds. Otherwise, <cite>None</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.distributions.read_distributions_from_config">
<code class="descclassname">pycbc.inference.distributions.</code><code class="descname">read_distributions_from_config</code><span class="sig-paren">(</span><em>cp</em>, <em>section='prior'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/distributions.html#read_distributions_from_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.distributions.read_distributions_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of PyCBC distribution instances for a section in the
given configuration file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cp</strong> : WorflowConfigParser</p>
<blockquote>
<div><p>An open config file to read.</p>
</div></blockquote>
<p><strong>section</strong> : {&#8220;prior&#8221;, string}</p>
<blockquote>
<div><p>Prefix on section names from which to retrieve the distributions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>A list of the parsed distributions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.likelihood">
<span id="pycbc-inference-likelihood-module"></span><h2>pycbc.inference.likelihood module<a class="headerlink" href="#module-pycbc.inference.likelihood" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for evaluating the log likelihood
for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.likelihood.GaussianLikelihood">
<em class="property">class </em><code class="descclassname">pycbc.inference.likelihood.</code><code class="descname">GaussianLikelihood</code><span class="sig-paren">(</span><em>waveform_generator</em>, <em>data</em>, <em>f_lower</em>, <em>psds=None</em>, <em>f_upper=None</em>, <em>norm=None</em>, <em>prior=None</em>, <em>return_meta=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/likelihood.html#GaussianLikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.likelihood.GaussianLikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.likelihood._BaseLikelihoodEvaluator</span></code></p>
<p>Computes log likelihoods assuming the detectors&#8217; noise is Gaussian.</p>
<p>With Gaussian noise the log likelihood functions for signal
<img src="_images/mathmpl/math-505add5536.png" style="position: relative; bottom: -8px"/> and for noise <img src="_images/mathmpl/math-36d785eb1a.png" style="position: relative; bottom: -8px"/> are given by:</p>
<img src="_images/mathmpl/math-902c41a92d.png" class="center" /><p>where the sum is over the number of detectors, <img src="_images/mathmpl/math-d82512cc4e.png" style="position: relative; bottom: -6px"/> is the data in
each detector, and <img src="_images/mathmpl/math-fb8aaadbc9.png" style="position: relative; bottom: -8px"/> is the model signal in each
detector. The inner product is given by:</p>
<img src="_images/mathmpl/math-cb481c93c4.png" class="center" /><p>where <img src="_images/mathmpl/math-38368e9fc8.png" style="position: relative; bottom: -8px"/> is the PSD in the given detector.</p>
<p>Note that the log prior-weighted likelihood ratio has one less term
than the log posterior, since the <img src="_images/mathmpl/math-4db273aac0.png" style="position: relative; bottom: -8px"/> term cancels
in the likelihood ratio:</p>
<img src="_images/mathmpl/math-49711cbd38.png" class="center" /><p>For this reason, by default this class returns <cite>logplr</cite> when called as a
function instead of <cite>logposterior</cite>. This can be changed via the
<cite>set_callfunc</cite> method.</p>
<p>Upon initialization, the data is whitened using the given PSDs. If no PSDs
are given the data and waveforms returned by the waveform generator are
assumed to be whitened. The likelihood function of the noise,</p>
<img src="_images/mathmpl/math-368ecb1e66.png" class="center" /><p>is computed on initialization and stored as the <cite>lognl</cite> attribute.</p>
<p>By default, the data is assumed to be equally sampled in frequency, but
unequally sampled data can be supported by passing the appropriate
normalization using the <cite>norm</cite> keyword argument.</p>
<p>For more details on initialization parameters and definition of terms, see
<cite>_BaseLikelihoodEvaluator</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>waveform_generator</strong> : generator class</p>
<blockquote>
<div><p>A generator class that creates waveforms. This must have a generate
function which takes a set of parameter values as arguments, a
detectors attribute which is a dictionary of detectors keyed by their
names, and an epoch which specifies the start time of the generated
waveform.</p>
</div></blockquote>
<p><strong>data</strong> : dict</p>
<blockquote>
<div><p>A dictionary of data, in which the keys are the detector names and the
values are the data (assumed to be unwhitened). The list of keys must
match the waveform generator&#8217;s detectors keys, and the epoch of every
data set must be the same as the waveform generator&#8217;s epoch.</p>
</div></blockquote>
<p><strong>f_lower</strong> : float</p>
<blockquote>
<div><p>The starting frequency to use for computing inner products.</p>
</div></blockquote>
<p><strong>psds</strong> : {None, dict}</p>
<blockquote>
<div><p>A dictionary of FrequencySeries keyed by the detector names. The
dictionary must have a psd for each detector specified in the data
dictionary. If provided, the inner products in each detector will be
weighted by 1/psd of that detector.</p>
</div></blockquote>
<p><strong>f_upper</strong> : {None, float}</p>
<blockquote>
<div><p>The ending frequency to use for computing inner products. If not
provided, the minimum of the largest frequency stored in the data
and a given waveform will be used.</p>
</div></blockquote>
<p><strong>norm</strong> : {None, float or array}</p>
<blockquote>
<div><p>An extra normalization weight to apply to the inner products. Can be
either a float or an array. If <cite>None</cite>, <a href="#id1"><span class="problematic" id="id2">`</span></a>4*data.values()[0].delta_f
will be used.</p>
</div></blockquote>
<p><strong>prior</strong> : callable</p>
<blockquote>
<div><p>A callable class or function that computes the prior.</p>
</div></blockquote>
<p><strong>return_meta</strong> : {True, bool}</p>
<blockquote class="last">
<div><p>If True, <cite>logposterior</cite> and <cite>logplr</cite> will return the value of the
prior and the loglikelihood ratio, along with the posterior/plr.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create a signal, and set up the likelihood evaluator on that signal:
&gt;&gt;&gt; seglen = 4
&gt;&gt;&gt; sample_rate = 2048
&gt;&gt;&gt; N = seglen*sample_rate/2+1
&gt;&gt;&gt; fmin = 30.
&gt;&gt;&gt; m1, m2, s1z, s2z, tsig, ra, dec, pol, dist = 38.6, 29.3, 0., 0., 3.1, 1.37, -1.26, 2.76, 3*500.
&gt;&gt;&gt; generator = waveform.FDomainDetFrameGenerator(waveform.FDomainCBCGenerator, 0., variable_args=[&#8216;tc&#8217;], detectors=[&#8216;H1&#8217;, &#8216;L1&#8217;], delta_f=1./seglen, f_lower=fmin, approximant=&#8217;SEOBNRv2_ROM_DoubleSpin&#8217;, mass1=m1, mass2=m2, spin1z=s1z, spin2z=s2z, ra=ra, dec=dec, polarization=pol, distance=dist)
&gt;&gt;&gt; signal = generator.generate(tsig)
&gt;&gt;&gt; psd = pypsd.aLIGOZeroDetHighPower(N, 1./seglen, 20.)
&gt;&gt;&gt; psds = {&#8216;H1&#8217;: psd, &#8216;L1&#8217;: psd}
&gt;&gt;&gt; likelihood_eval = inference.GaussianLikelihood(generator, signal, fmin, psds=psds, return_meta=False)</p>
<p>Now compute the log likelihood ratio and prior-weighted likelihood ratio;
since we have not provided a prior, these should be equal to each other:
&gt;&gt;&gt; likelihood_eval.loglr([tsig]), likelihood_eval.logplr([tsig])
(ArrayWithAligned(277.92945279883855), ArrayWithAligned(277.92945279883855))</p>
<p>Compute the log likelihood and log posterior; since we have not
provided a prior, these should both be equal to zero:
&gt;&gt;&gt; likelihood_eval.loglikelihood([tsig]), likelihood_eval.logposterior([tsig])
(ArrayWithAligned(0.0), ArrayWithAligned(0.0))</p>
<p>Compute the SNR; for this system and PSD, this should be approximately 24:
&gt;&gt;&gt; likelihood_eval.snr([tsig])
ArrayWithAligned(23.576660187517593)</p>
<p>Using the same likelihood evaluator, evaluate the log prior-weighted
likelihood ratio at several points in time, check that the max is at tsig,
and plot (note that we use the class as a function here, which defaults
to calling <cite>logplr</cite>):
&gt;&gt;&gt; from matplotlib import pyplot
&gt;&gt;&gt; times = numpy.arange(seglen*sample_rate)/float(sample_rate)
&gt;&gt;&gt; lls = numpy.array([likelihood_eval([t]) for t in times])
&gt;&gt;&gt; times[lls.argmax()]
3.10009765625
&gt;&gt;&gt; fig = pyplot.figure(); ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(times, lls)
[&lt;matplotlib.lines.Line2D at 0x1274b5c50&gt;]
&gt;&gt;&gt; fig.show()</p>
<p>Create a prior and use it (see prior module for more details):
&gt;&gt;&gt; from pycbc.inference import prior
&gt;&gt;&gt; uniform_prior = prior.Uniform(tc=(tsig-0.2,tsig+0.2))
&gt;&gt;&gt; prior_eval = prior.PriorEvaluator([&#8216;tc&#8217;], uniform_prior)
&gt;&gt;&gt; likelihood_eval = inference.GaussianLikelihood(generator, signal, 20., psds=psds, prior=prior_eval, return_meta=False)
&gt;&gt;&gt; likelihood_eval.logplr([tsig]), likelihood_eval.logposterior([tsig])
(ArrayWithAligned(278.84574353071264), ArrayWithAligned(0.9162907318741418))</p>
<dl class="method">
<dt id="pycbc.inference.likelihood.GaussianLikelihood.loglikelihood">
<code class="descname">loglikelihood</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/likelihood.html#GaussianLikelihood.loglikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.likelihood.GaussianLikelihood.loglikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log likelihood of the paramaters,</p>
<img src="_images/mathmpl/math-98ecf8427e.png" class="center" /><p>p(d|Theta) = -frac{1}{2}sum_i left&lt;h_i(Theta) - d_i | h_i(Theta) - d_iright&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: array-like</strong></p>
<blockquote>
<div><p>An array of numerical values to pass to the waveform generator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>The value of the log likelihood evaluated at the given point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.likelihood.GaussianLikelihood.loglr">
<code class="descname">loglr</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/likelihood.html#GaussianLikelihood.loglr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.likelihood.GaussianLikelihood.loglr" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log likelihood ratio,</p>
<img src="_images/mathmpl/math-bbd282782b.png" class="center" /><p>at the given point in parameter space <img src="_images/mathmpl/math-98c28d2d1b.png" style="position: relative; bottom: -3px"/>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: array-like</strong></p>
<blockquote>
<div><p>An array of numerical values to pass to the waveform generator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote class="last">
<div><p>The value of the log likelihood ratio evaluated at the given point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.likelihood.GaussianLikelihood.lognl">
<code class="descname">lognl</code><a class="headerlink" href="#pycbc.inference.likelihood.GaussianLikelihood.lognl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.likelihood.GaussianLikelihood.logposterior">
<code class="descname">logposterior</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/likelihood.html#GaussianLikelihood.logposterior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.likelihood.GaussianLikelihood.logposterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log-posterior probability at the given point in
parameter space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: array-like</strong></p>
<blockquote>
<div><p>An array of numerical values to pass to the waveform generator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">float</p>
<blockquote>
<div><p>The value of the log-posterior evaluated at the given point in
parameter space.</p>
</div></blockquote>
<p><strong>metadata</strong> : tuple</p>
<blockquote class="last">
<div><p>If <cite>return_meta</cite>, the prior and likelihood ratio as a tuple.
Otherwise, just returns the log-posterior.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.likelihood.GaussianLikelihood.name">
<code class="descname">name</code><em class="property"> = 'gaussian'</em><a class="headerlink" href="#pycbc.inference.likelihood.GaussianLikelihood.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.option_utils">
<span id="pycbc-inference-option-utils-module"></span><h2>pycbc.inference.option_utils module<a class="headerlink" href="#module-pycbc.inference.option_utils" title="Permalink to this headline">¶</a></h2>
<p>This module contains standard options used for inference-related programs.</p>
<dl class="function">
<dt id="pycbc.inference.option_utils.add_density_option_group">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">add_density_option_group</code><span class="sig-paren">(</span><em>parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#add_density_option_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.add_density_option_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the options needed to configure contours and density colour map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parser</strong> : object</p>
<blockquote class="last">
<div><p>ArgumentParser instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.option_utils.add_inference_results_option_group">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">add_inference_results_option_group</code><span class="sig-paren">(</span><em>parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#add_inference_results_option_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.add_inference_results_option_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the options used to call pycbc.inference.results_from_cli function
to an argument parser. These are options releated to loading the results
from a run of pycbc_inference, for purposes of plotting and/or creating
tables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parser</strong> : object</p>
<blockquote class="last">
<div><p>ArgumentParser instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.option_utils.add_plot_posterior_option_group">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">add_plot_posterior_option_group</code><span class="sig-paren">(</span><em>parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#add_plot_posterior_option_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.add_plot_posterior_option_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the options needed to configure plots of posterior results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parser</strong> : object</p>
<blockquote class="last">
<div><p>ArgumentParser instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.option_utils.add_sampler_option_group">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">add_sampler_option_group</code><span class="sig-paren">(</span><em>parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#add_sampler_option_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.add_sampler_option_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the options needed to set up an inference sampler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parser</strong> : object</p>
<blockquote class="last">
<div><p>ArgumentParser instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.option_utils.add_scatter_option_group">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">add_scatter_option_group</code><span class="sig-paren">(</span><em>parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#add_scatter_option_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.add_scatter_option_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the options needed to configure scatter plots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parser</strong> : object</p>
<blockquote class="last">
<div><p>ArgumentParser instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.option_utils.get_zvalues">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">get_zvalues</code><span class="sig-paren">(</span><em>fp</em>, <em>arg</em>, <em>likelihood_stats</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#get_zvalues"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.get_zvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the data for the z-value of the plots from the inference file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open inference file; needed to get the value of the log noise
likelihood.</p>
</div></blockquote>
<p><strong>arg</strong> : str</p>
<blockquote>
<div><p>The argument to plot; must be one of <cite>loglr</cite>, <cite>snr</cite>, <cite>logplr</cite>,
<cite>logposterior</cite>, or <cite>prior</cite>. If not one of these, a ValueError is
raised.</p>
</div></blockquote>
<p><strong>likelihood_stats</strong> : FieldArray</p>
<blockquote>
<div><p>The likelihood stats; the sort of thing returned by
<cite>fp.read_likelihood_stats</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>zvals</strong> : numpy.array</p>
<blockquote>
<div><p>An array of the desired likelihood values to plot.</p>
</div></blockquote>
<p><strong>zlbl</strong> : str</p>
<blockquote class="last">
<div><p>The label to use for the values on a plot.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.option_utils.plot_ranges_from_cli">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">plot_ranges_from_cli</code><span class="sig-paren">(</span><em>opts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#plot_ranges_from_cli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.plot_ranges_from_cli" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses the mins and maxs arguments from the <cite>plot_posterior</cite> option
group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>opts</strong> : ArgumentParser</p>
<blockquote>
<div><p>The parsed arguments from the command line.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mins</strong> : dict</p>
<blockquote>
<div><p>Dictionary of parameter name -&gt; specified mins. Only parameters that
were specified in the &#8211;mins option will be included; if no parameters
were provided, will return an empty dictionary.</p>
</div></blockquote>
<p><strong>maxs</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of parameter name -&gt; specified maxs. Only parameters that
were specified in the &#8211;mins option will be included; if no parameters
were provided, will return an empty dictionary.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.option_utils.results_from_cli">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">results_from_cli</code><span class="sig-paren">(</span><em>opts</em>, <em>load_samples=True</em>, <em>walkers=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#results_from_cli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.results_from_cli" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads an inference result file along with any labels associated with it
from the command line options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>opts</strong> : ArgumentParser options</p>
<blockquote>
<div><p>The options from the command line.</p>
</div></blockquote>
<p><strong>load_samples</strong> : {True, bool}</p>
<blockquote>
<div><p>Load samples from the results file using the parameters, thin_start,
and thin_interval specified in the options. The samples are returned
as a WaveformArray instance.</p>
</div></blockquote>
<p><strong>walkers</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>If loading samples, the walkers to load from. If None, will load from
all walkers.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result_file</strong> : pycbc.io.InferenceFile</p>
<blockquote>
<div><p>The result file as an InferenceFile.</p>
</div></blockquote>
<p><strong>parameters</strong> : list</p>
<blockquote>
<div><p>List of the parameters to use, parsed from the parameters option.</p>
</div></blockquote>
<p><strong>labels</strong> : list</p>
<blockquote>
<div><p>List of labels to associate with the parameters.</p>
</div></blockquote>
<p><strong>samples</strong> : {None, WaveformArray}</p>
<blockquote class="last">
<div><p>If load_samples, the samples as a WaveformArray; otherwise, None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.inference.option_utils.sampler_from_cli">
<code class="descclassname">pycbc.inference.option_utils.</code><code class="descname">sampler_from_cli</code><span class="sig-paren">(</span><em>opts</em>, <em>likelihood_evaluator</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/option_utils.html#sampler_from_cli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.option_utils.sampler_from_cli" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses the given command-line options to set up a sampler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>opts</strong> : object</p>
<blockquote>
<div><p>ArgumentParser options.</p>
</div></blockquote>
<p><strong>likelihood_evaluator</strong> : LikelihoodEvaluator</p>
<blockquote>
<div><p>The likelihood evaluator to use with the sampler.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pycbc.inference.sampler</p>
<blockquote class="last">
<div><p>A sampler initialized based on the given arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.prior">
<span id="pycbc-inference-prior-module"></span><h2>pycbc.inference.prior module<a class="headerlink" href="#module-pycbc.inference.prior" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for evaluating the prior
for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.prior.PriorEvaluator">
<em class="property">class </em><code class="descclassname">pycbc.inference.prior.</code><code class="descname">PriorEvaluator</code><span class="sig-paren">(</span><em>variable_args</em>, <em>*distributions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/prior.html#PriorEvaluator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.prior.PriorEvaluator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Callable class that calculates the prior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>variable_args</strong> : list</p>
<blockquote>
<div><p>A list of strings that contain the names of the variable parameters and
the order they are expected when the class is called.</p>
</div></blockquote>
<p><strong>*distributions :</strong></p>
<blockquote class="last">
<div><p>The rest of the arguments must be instances of distributions describing
the priors on the variable parameters. A single distribution may contain
multiple parameters. The set of all params across the distributions
(retrieved from the distributions&#8217; params attribute) must be the same
as the set of variable_args provided.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>variable_args</td>
<td>(tuple) The parameters expected when the evaluator is called.</td>
</tr>
<tr class="row-even"><td>distributions</td>
<td>(list) The distributions for the parameters.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.prior.PriorEvaluator.apply_boundary_conditions">
<code class="descname">apply_boundary_conditions</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/prior.html#PriorEvaluator.apply_boundary_conditions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.prior.PriorEvaluator.apply_boundary_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies each distributions&#8217; boundary conditions to the given list
of parameters, returning a new list with the conditions applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : list</p>
<blockquote>
<div><p>List of parameters to apply conditions to. The order of the
parameters is assumed to be the same as self.variable_args.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list</p>
<blockquote class="last">
<div><p>List of the parameters after each distribution&#8217;s
<cite>apply_boundary_conditions</cite> function has been applied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler">
<span id="pycbc-inference-sampler-module"></span><h2>pycbc.inference.sampler module<a class="headerlink" href="#module-pycbc.inference.sampler" title="Permalink to this headline">¶</a></h2>
<p>This modules provides a list of implemented samplers for parameter estimation.</p>
</div>
<div class="section" id="module-pycbc.inference.sampler_base">
<span id="pycbc-inference-sampler-base-module"></span><h2>pycbc.inference.sampler_base module<a class="headerlink" href="#module-pycbc.inference.sampler_base" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using different sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler_base.</code><code class="descname">BaseMCMCSampler</code><span class="sig-paren">(</span><em>sampler</em>, <em>likelihood_evaluator</em>, <em>min_burn_in=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.sampler_base._BaseSampler</span></code></p>
<p>This class is used to construct the MCMC sampler from the kombine-like
packages.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sampler</strong> : sampler instance</p>
<blockquote>
<div><p>An instance of an MCMC sampler similar to kombine or emcee.</p>
</div></blockquote>
<p><strong>likelihood_evaluator</strong> : likelihood class</p>
<blockquote>
<div><p>An instance of the likelihood class from the
pycbc.inference.likelihood module.</p>
</div></blockquote>
<p><strong>min_burn_in</strong> : {None, int}</p>
<blockquote class="last">
<div><p>Set the minimum number of burn in iterations to use. If None,
<cite>burn_in_iterations</cite> will be initialized to <cite>0</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>sampler :</td>
<td>The MCMC sampler instance used.</td>
</tr>
<tr class="row-even"><td>p0</td>
<td>(nwalkers x ndim array) The initial position of the walkers. Set by using set_p0. If not set yet, a ValueError is raised when the attribute is accessed.</td>
</tr>
<tr class="row-odd"><td>pos</td>
<td>({None, array}) An array of the current walker positions.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.acceptance_fraction">
<code class="descname">acceptance_fraction</code><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.acceptance_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the fraction of walkers that accepted each step as an array.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.compute_acls">
<em class="property">classmethod </em><code class="descname">compute_acls</code><span class="sig-paren">(</span><em>fp</em>, <em>start_index=None</em>, <em>end_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.compute_acls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.compute_acls" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrleation length for all variable args and all
walkers in the given file. If the returned acl is inf, will default
to the number of requested iterations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the samples from.</p>
</div></blockquote>
<p><strong>start_index</strong> : {None, int}</p>
<blockquote>
<div><p>The start index to compute the acl from. If None, will try to use
the number of burn-in iterations in the file; otherwise, will start
at the first sample.</p>
</div></blockquote>
<p><strong>end_index</strong> : {None, int}</p>
<blockquote>
<div><p>The end index to compute the acl to. If None, will go to the end
of the current iteration.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">WaveformArray</p>
<blockquote class="last">
<div><p>An nwalkers-long <cite>WaveformArray</cite> containing the acl for each walker
and each variable argument, with the variable arguments as fields.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.likelihood_stats">
<code class="descname">likelihood_stats</code><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.likelihood_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the likelihood stats as a FieldArray, with field names
corresponding to the type of data returned by the likelihood evaluator.
The returned array has shape nwalkers x niterations. If no additional
stats were returned to the sampler by the likelihood evaluator, returns
None.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.name">
<code class="descname">name</code><em class="property"> = None</em><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.nwalkers">
<code class="descname">nwalkers</code><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.nwalkers" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of walkers.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.p0">
<code class="descname">p0</code><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.p0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.pos">
<code class="descname">pos</code><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.read_acceptance_fraction">
<em class="property">static </em><code class="descname">read_acceptance_fraction</code><span class="sig-paren">(</span><em>fp</em>, <em>thin_start=None</em>, <em>thin_interval=None</em>, <em>thin_end=None</em>, <em>iteration=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.read_acceptance_fraction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.read_acceptance_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the acceptance fraction from the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the samples from.</p>
</div></blockquote>
<p><strong>walkers</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>The walker index (or a list of indices) to retrieve. If None,
samples from all walkers will be obtained.</p>
</div></blockquote>
<p><strong>thin_start</strong> : int</p>
<blockquote>
<div><p>Index of the sample to begin returning samples. Default is to read
samples after burn in. To start from the beginning set thin_start
to 0.</p>
</div></blockquote>
<p><strong>thin_interval</strong> : int</p>
<blockquote>
<div><p>Interval to accept every i-th sample. Default is to use the
<cite>fp.acl</cite>. If <cite>fp.acl</cite> is not set, then use all samples
(set thin_interval to 1).</p>
</div></blockquote>
<p><strong>thin_end</strong> : int</p>
<blockquote>
<div><p>Index of the last sample to read. If not given then
<cite>fp.niterations</cite> is used.</p>
</div></blockquote>
<p><strong>iteration</strong> : int</p>
<blockquote>
<div><p>Get a single iteration. If provided, will override the
<cite>thin_{start/interval/end}</cite> arguments.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array</p>
<blockquote class="last">
<div><p>Array of acceptance fractions with shape (requested iterations,).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.read_acls">
<em class="property">static </em><code class="descname">read_acls</code><span class="sig-paren">(</span><em>fp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.read_acls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.read_acls" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the acls of all the walker chains saved in the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the acls from.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">WaveformArray</p>
<blockquote class="last">
<div><p>An nwalkers-long <cite>WaveformArray</cite> containing the acl for each walker
and each variable argument, with the variable arguments as fields.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.read_likelihood_stats">
<em class="property">classmethod </em><code class="descname">read_likelihood_stats</code><span class="sig-paren">(</span><em>fp</em>, <em>thin_start=None</em>, <em>thin_interval=None</em>, <em>thin_end=None</em>, <em>iteration=None</em>, <em>walkers=None</em>, <em>flatten=True</em>, <em>stats_group=None</em>, <em>array_class=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.read_likelihood_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.read_likelihood_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the likelihood stats from the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the stats from.</p>
</div></blockquote>
<p><strong>thin_start</strong> : int</p>
<blockquote>
<div><p>Index of the sample to begin returning stats. Default is to read
stats after burn in. To start from the beginning set thin_start
to 0.</p>
</div></blockquote>
<p><strong>thin_interval</strong> : int</p>
<blockquote>
<div><p>Interval to accept every i-th sample. Default is to use the
<cite>fp.acl</cite>. If <cite>fp.acl</cite> is not set, then use all stats
(set thin_interval to 1).</p>
</div></blockquote>
<p><strong>thin_end</strong> : int</p>
<blockquote>
<div><p>Index of the last sample to read. If not given then
<cite>fp.niterations</cite> is used.</p>
</div></blockquote>
<p><strong>iteration</strong> : int</p>
<blockquote>
<div><p>Get a single iteration. If provided, will override the
<cite>thin_{start/interval/end}</cite> arguments.</p>
</div></blockquote>
<p><strong>walkers</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>The walker index (or a list of indices) to retrieve. If None,
stats from all walkers will be obtained.</p>
</div></blockquote>
<p><strong>flatten</strong> : {True, bool}</p>
<blockquote>
<div><p>The returned array will be one dimensional, with all desired
stats from all desired walkers concatenated together. If False,
the returned array will have dimension requested walkers
x requested iterations.</p>
</div></blockquote>
<p><strong>stats_group</strong> : {None, str}</p>
<blockquote>
<div><p>The group in <cite>fp</cite> from which to retrieve the stats. If
None, searches in <cite>fp.stats_group</cite>.</p>
</div></blockquote>
<p><strong>array_class</strong> : {None, array class}</p>
<blockquote>
<div><p>The type of array to return. The class must have a <cite>from_kwargs</cite>
class method. If None, will return a FieldArray.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array_class</p>
<blockquote class="last">
<div><p>The likelihood stats, as an instance of a the given
<cite>array_class</cite> (<cite>FieldArray</cite> if <cite>array_class</cite> is None).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.read_samples">
<em class="property">classmethod </em><code class="descname">read_samples</code><span class="sig-paren">(</span><em>fp</em>, <em>parameters</em>, <em>thin_start=None</em>, <em>thin_interval=None</em>, <em>thin_end=None</em>, <em>iteration=None</em>, <em>walkers=None</em>, <em>flatten=True</em>, <em>samples_group=None</em>, <em>array_class=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.read_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.read_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads samples for the given parameter(s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the samples from.</p>
</div></blockquote>
<p><strong>parameters</strong> : (list of) strings</p>
<blockquote>
<div><p>The parameter(s) to retrieve. A parameter can be the name of any
field in <cite>fp[fp.samples_group]</cite>, a virtual field or method of
<cite>WaveformArray</cite> (as long as the file contains the necessary fields
to derive the virtual field or method), and/or a function of
these.</p>
</div></blockquote>
<p><strong>thin_start</strong> : int</p>
<blockquote>
<div><p>Index of the sample to begin returning samples. Default is to read
samples after burn in. To start from the beginning set thin_start
to 0.</p>
</div></blockquote>
<p><strong>thin_interval</strong> : int</p>
<blockquote>
<div><p>Interval to accept every i-th sample. Default is to use the
<cite>fp.acl</cite>. If <cite>fp.acl</cite> is not set, then use all samples
(set thin_interval to 1).</p>
</div></blockquote>
<p><strong>thin_end</strong> : int</p>
<blockquote>
<div><p>Index of the last sample to read. If not given then
<cite>fp.niterations</cite> is used.</p>
</div></blockquote>
<p><strong>iteration</strong> : int</p>
<blockquote>
<div><p>Get a single iteration. If provided, will override the
<cite>thin_{start/interval/end}</cite> arguments.</p>
</div></blockquote>
<p><strong>walkers</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>The walker index (or a list of indices) to retrieve. If None,
samples from all walkers will be obtained.</p>
</div></blockquote>
<p><strong>flatten</strong> : {True, bool}</p>
<blockquote>
<div><p>The returned array will be one dimensional, with all desired
samples from all desired walkers concatenated together. If False,
the returned array will have dimension requested walkers
x requested iterations.</p>
</div></blockquote>
<p><strong>samples_group</strong> : {None, str}</p>
<blockquote>
<div><p>The group in <cite>fp</cite> from which to retrieve the parameter fields. If
None, searches in <cite>fp.samples_group</cite>.</p>
</div></blockquote>
<p><strong>array_class</strong> : {None, array class}</p>
<blockquote>
<div><p>The type of array to return. The class must have a <cite>from_kwargs</cite>
class method and a <cite>parse_parameters</cite> method. If None, will return
a WaveformArray.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array_class</p>
<blockquote class="last">
<div><p>Samples for the given parameters, as an instance of a the given
<cite>array_class</cite> (<cite>WaveformArray</cite> if <cite>array_class</cite> is None).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.sampler">
<code class="descname">sampler</code><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.sampler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.set_p0">
<code class="descname">set_p0</code><span class="sig-paren">(</span><em>prior_distributions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.set_p0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.set_p0" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the initial position of the walkers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>prior_distributions</strong> : list</p>
<blockquote>
<div><p>A list of priors to retrieve random values from (the sort of
thing returned by <cite>prior.read_distributions_from_config</cite>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p0</strong> : array</p>
<blockquote class="last">
<div><p>An nwalkers x ndim array of the initial positions that were set.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.write_acceptance_fraction">
<code class="descname">write_acceptance_fraction</code><span class="sig-paren">(</span><em>fp</em>, <em>start_iteration=0</em>, <em>end_iteration=None</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.write_acceptance_fraction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.write_acceptance_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Write acceptance_fraction data to file. Results are written to
<cite>fp[acceptance_fraction]</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
<p><strong>max_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>If acceptance fraction have not previously been written to the
file, a new dataset will be created. By default, the size of this
dataset will be whatever the length of the sampler&#8217;s chain is at
this point. If you intend to run more iterations, set this value
to that size so that arrays in the file will be large enough to
accomodate future data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.write_acls">
<em class="property">static </em><code class="descname">write_acls</code><span class="sig-paren">(</span><em>fp</em>, <em>acls</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.write_acls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.write_acls" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the given autocorrelation lengths to the given file. The acl
of each walker and each parameter is saved to
<cite>fp[fp.samples_group/{param}/walker{i}].attrs[&#8216;acl&#8217;]</cite>; the maximum
over all the walkers for a given param is saved to
<cite>fp[fp.samples_group/{param}].attrs[&#8216;acl&#8217;]</cite>; the maximum over all the
parameters and all of the walkers is saved to the file&#8217;s &#8216;acl&#8217;
attribute.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to write the samples to.</p>
</div></blockquote>
<p><strong>acls</strong> : WaveformArray</p>
<blockquote>
<div><p>An array of autocorrelation lengths (the sort of thing returned by
<cite>compute_acls</cite>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">acl</p>
<blockquote class="last">
<div><p>The maximum of the acls that was written to the file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.write_chain">
<code class="descname">write_chain</code><span class="sig-paren">(</span><em>fp</em>, <em>start_iteration=0</em>, <em>end_iteration=None</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.write_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.write_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the samples from the current chain to the given file. Results
are written to: <cite>fp[fp.samples_group/{vararg}/walker{i}]</cite>, where
<cite>{vararg}</cite> is the name of a variable arg, and <cite>{i}</cite> is the index of
a walker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
<p><strong>start_iteration</strong> : {0, int}</p>
<blockquote>
<div><p>Write results starting from the given iteration.</p>
</div></blockquote>
<p><strong>end_iteration</strong> : {None, int}</p>
<blockquote>
<div><p>Write results up to the given iteration.</p>
</div></blockquote>
<p><strong>max_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>If samples have not previously been written to the file, a new
dataset will be created. By default, the size of this dataset will
be whatever the length of the sampler&#8217;s chain is at this point. If
you intend to run more iterations, set this value to that size so
that the array in the file will be large enough to accomodate
future data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.write_likelihood_stats">
<code class="descname">write_likelihood_stats</code><span class="sig-paren">(</span><em>fp</em>, <em>start_iteration=0</em>, <em>end_iteration=None</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.write_likelihood_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.write_likelihood_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the <cite>likelihood_stats</cite> to the given file.  Results are
written to: <cite>fp[fp.stats_group/{field}/walker{i}]</cite>, where <cite>{i}</cite> is
the index of a walker and <cite>{field}</cite> is the name of each field returned
by <cite>likelihood_stats</cite>. If nothing is returned by <cite>likelihood_stats</cite>,
this does nothing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
<p><strong>start_iteration</strong> : {0, int}</p>
<blockquote>
<div><p>Write results starting from the given iteration.</p>
</div></blockquote>
<p><strong>end_iteration</strong> : {None, int}</p>
<blockquote>
<div><p>Write results up to the given iteration.</p>
</div></blockquote>
<p><strong>max_iterations</strong> : {None, int}</p>
<blockquote>
<div><p>If the stats have not previously been written to the file, a new
dataset will be created. By default, the size of this dataset will
be whatever the length of the sampler&#8217;s chain is at this point. If
you intend to run more iterations, set this value to that size so
that the array in the file will be large enough to accomodate
future data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>stats</strong> : {FieldArray, None}</p>
<blockquote class="last">
<div><p>The stats that were written, as a FieldArray. If there were no
stats, returns None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.write_metadata">
<code class="descname">write_metadata</code><span class="sig-paren">(</span><em>fp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.write_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.write_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes metadata about this sampler to the given file. Metadata is
written to the file&#8217;s <cite>attrs</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote class="last">
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_base.BaseMCMCSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>fp</em>, <em>start_iteration=0</em>, <em>end_iteration=None</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_base.html#BaseMCMCSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_base.BaseMCMCSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes metadata, samples, likelihood stats, and acceptance fraction
to the given file. Also computes and writes the autocorrleation lengths
of the chains. See the various write function for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
<p><strong>start_iteration</strong> : {0, int}</p>
<blockquote>
<div><p>Write results starting from the given iteration.</p>
</div></blockquote>
<p><strong>end_iteration</strong> : {None, int}</p>
<blockquote>
<div><p>Write results up to the given iteration.</p>
</div></blockquote>
<p><strong>max_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>If results have not previously been written to the
file, new datasets will be created. By default, the size of these
datasets will be whatever the length of the sampler&#8217;s chain is at
this point. If you intend to run more iterations in the future,
set this value to that size so that the array in the file will be
large enough to accomodate future data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler_emcee">
<span id="pycbc-inference-sampler-emcee-module"></span><h2>pycbc.inference.sampler_emcee module<a class="headerlink" href="#module-pycbc.inference.sampler_emcee" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using the emcee sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler_emcee.</code><code class="descname">EmceeEnsembleSampler</code><span class="sig-paren">(</span><em>likelihood_evaluator</em>, <em>nwalkers</em>, <em>processes=None</em>, <em>burn_in_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceeEnsembleSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler_base.BaseMCMCSampler" title="pycbc.inference.sampler_base.BaseMCMCSampler"><code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.sampler_base.BaseMCMCSampler</span></code></a></p>
<p>This class is used to construct an MCMC sampler from the emcee
package&#8217;s EnsembleSampler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>likelihood_evaluator</strong> : likelihood class</p>
<blockquote>
<div><p>An instance of the likelihood class from the
pycbc.inference.likelihood module.</p>
</div></blockquote>
<p><strong>nwalkers</strong> : int</p>
<blockquote>
<div><p>Number of walkers to use in sampler.</p>
</div></blockquote>
<p><strong>processes</strong> : {None, int}</p>
<blockquote>
<div><p>Number of processes to use with multiprocessing. If None, all available
cores are used.</p>
</div></blockquote>
<p><strong>burn_in_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>Set the number of burn in iterations to use. If None,
<cite>burn_in_ieterations</cite> will be initialized to 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.burn_in">
<code class="descname">burn_in</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceeEnsembleSampler.burn_in"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.burn_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the ensemble by the number of the sampler&#8217;s
<cite>burn_in_iterations</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : numpy.array</p>
<blockquote>
<div><p>An array of current walker positions with shape (nwalkers, ndim).</p>
</div></blockquote>
<p><strong>lnpost</strong> : {None, numpy.array}</p>
<blockquote>
<div><p>The list of log posterior probabilities for the walkers at
positions p, with shape (nwalkers, ndim).</p>
</div></blockquote>
<p>rstate :</p>
<blockquote class="last">
<div><p>The current state of the random number generator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.chain">
<code class="descname">chain</code><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all past samples as an nwalker x niterations x ndim array.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.clear_chain">
<code class="descname">clear_chain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceeEnsembleSampler.clear_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.clear_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the chain and blobs from memory.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.from_cli">
<em class="property">classmethod </em><code class="descname">from_cli</code><span class="sig-paren">(</span><em>opts</em>, <em>likelihood_evaluator</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceeEnsembleSampler.from_cli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.from_cli" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance of this sampler from the given command-line
options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>opts</strong> : ArgumentParser options</p>
<blockquote>
<div><p>The options to parse.</p>
</div></blockquote>
<p><strong>likelihood_evaluator</strong> : LikelihoodEvaluator</p>
<blockquote>
<div><p>The likelihood evaluator to use with the sampler.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">EmceeEnsembleSampler</p>
<blockquote class="last">
<div><p>An emcee sampler initialized based on the given arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.lnpost">
<code class="descname">lnpost</code><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.lnpost" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the natural logarithm of the likelihood as an
nwalkers x niterations array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.name">
<code class="descname">name</code><em class="property"> = 'emcee'</em><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.read_acceptance_fraction">
<em class="property">static </em><code class="descname">read_acceptance_fraction</code><span class="sig-paren">(</span><em>fp</em>, <em>walkers=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceeEnsembleSampler.read_acceptance_fraction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.read_acceptance_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the acceptance fraction from the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the samples from.</p>
</div></blockquote>
<p><strong>walkers</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>The walker index (or a list of indices) to retrieve. If None,
samples from all walkers will be obtained.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array</p>
<blockquote class="last">
<div><p>Array of acceptance fractions with shape (requested walkers,).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>niterations</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceeEnsembleSampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the ensemble for a number of samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>niterations</strong> : int</p>
<blockquote>
<div><p>Number of samples to get from sampler.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : numpy.array</p>
<blockquote>
<div><p>An array of current walker positions with shape (nwalkers, ndim).</p>
</div></blockquote>
<p><strong>lnpost</strong> : numpy.array</p>
<blockquote>
<div><p>The list of log posterior probabilities for the walkers at
positions p, with shape (nwalkers, ndim).</p>
</div></blockquote>
<p>rstate :</p>
<blockquote class="last">
<div><p>The current state of the random number generator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.write_acceptance_fraction">
<code class="descname">write_acceptance_fraction</code><span class="sig-paren">(</span><em>fp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceeEnsembleSampler.write_acceptance_fraction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.write_acceptance_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Write acceptance_fraction data to file. Results are written to
<cite>fp[acceptance_fraction]</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote class="last">
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceeEnsembleSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>fp</em>, <em>start_iteration=0</em>, <em>end_iteration=None</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceeEnsembleSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceeEnsembleSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes metadata, samples, likelihood stats, and acceptance fraction
to the given file. See the write function for each of those for
details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
<p><strong>start_iteration</strong> : {0, int}</p>
<blockquote>
<div><p>Write results starting from the given iteration.</p>
</div></blockquote>
<p><strong>end_iteration</strong> : {None, int}</p>
<blockquote>
<div><p>Write results up to the given iteration.</p>
</div></blockquote>
<p><strong>max_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>If results have not previously been written to the
file, new datasets will be created. By default, the size of these
datasets will be whatever the length of the sampler&#8217;s chain is at
this point. If you intend to run more iterations in the future,
set this value to that size so that the array in the file will be
large enough to accomodate future data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler_emcee.</code><code class="descname">EmceePTSampler</code><span class="sig-paren">(</span><em>likelihood_evaluator</em>, <em>ntemps</em>, <em>nwalkers</em>, <em>processes=None</em>, <em>burn_in_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler_base.BaseMCMCSampler" title="pycbc.inference.sampler_base.BaseMCMCSampler"><code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.sampler_base.BaseMCMCSampler</span></code></a></p>
<p>This class is used to construct a parallel-tempered MCMC sampler from
the emcee package&#8217;s PTSampler.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>likelihood_evaluator</strong> : likelihood class</p>
<blockquote>
<div><p>An instance of the likelihood class from the
pycbc.inference.likelihood module.</p>
</div></blockquote>
<p><strong>ntemps</strong> : int</p>
<blockquote>
<div><p>Number of temeratures to use in the sampler.</p>
</div></blockquote>
<p><strong>nwalkers</strong> : int</p>
<blockquote>
<div><p>Number of walkers to use in sampler.</p>
</div></blockquote>
<p><strong>processes</strong> : {None, int}</p>
<blockquote>
<div><p>Number of processes to use with multiprocessing. If None, all available
cores are used.</p>
</div></blockquote>
<p><strong>burn_in_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>Set the number of burn in iterations to use. If None,
<cite>burn_in_ieterations</cite> will be initialized to 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.burn_in">
<code class="descname">burn_in</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.burn_in"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.burn_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the ensemble by the number of the sampler&#8217;s
<cite>burn_in_iterations</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : numpy.array</p>
<blockquote>
<div><p>An array of current walker positions with shape (nwalkers, ndim).</p>
</div></blockquote>
<p><strong>lnpost</strong> : {None, numpy.array}</p>
<blockquote>
<div><p>The list of log posterior probabilities for the walkers at
positions p, with shape (nwalkers, ndim).</p>
</div></blockquote>
<p>rstate :</p>
<blockquote class="last">
<div><p>The current state of the random number generator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.calculate_logevidence">
<em class="property">classmethod </em><code class="descname">calculate_logevidence</code><span class="sig-paren">(</span><em>fp</em>, <em>thin_start=None</em>, <em>thin_end=None</em>, <em>thin_interval=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.calculate_logevidence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.calculate_logevidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the log evidence from the given file using emcee&#8217;s
thermodynamic integration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the stats from.</p>
</div></blockquote>
<p><strong>thin_start</strong> : int</p>
<blockquote>
<div><p>Index of the sample to begin returning stats. Default is to read
stats after burn in. To start from the beginning set thin_start
to 0.</p>
</div></blockquote>
<p><strong>thin_interval</strong> : int</p>
<blockquote>
<div><p>Interval to accept every i-th sample. Default is to use the
<cite>fp.acl</cite>. If <cite>fp.acl</cite> is not set, then use all stats
(set thin_interval to 1).</p>
</div></blockquote>
<p><strong>thin_end</strong> : int</p>
<blockquote>
<div><p>Index of the last sample to read. If not given then
<cite>fp.niterations</cite> is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lnZ</strong> : float</p>
<blockquote>
<div><p>The estimate of log of the evidence.</p>
</div></blockquote>
<p><strong>dlnZ</strong> : float</p>
<blockquote class="last">
<div><p>The error on the estimate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.chain">
<code class="descname">chain</code><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all past samples as an ntemps x nwalker x niterations x ndim
array.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.clear_chain">
<code class="descname">clear_chain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.clear_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.clear_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the chain and blobs from memory.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.compute_acls">
<em class="property">classmethod </em><code class="descname">compute_acls</code><span class="sig-paren">(</span><em>fp</em>, <em>start_index=None</em>, <em>end_index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.compute_acls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.compute_acls" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the autocorrleation length for all variable args for all
walkers for all temps in the given file. If the returned acl is inf,
will default to the number of requested iterations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the samples from.</p>
</div></blockquote>
<p><strong>start_index</strong> : {None, int}</p>
<blockquote>
<div><p>The start index to compute the acl from. If None, will try to use
the number of burn-in iterations in the file; otherwise, will start
at the first sample.</p>
</div></blockquote>
<p><strong>end_index</strong> : {None, int}</p>
<blockquote>
<div><p>The end index to compute the acl to. If None, will go to the end
of the current iteration.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">WaveformArray</p>
<blockquote class="last">
<div><p>An ntemps x nwalkers <cite>WaveformArray</cite> containing the acl for each
walker and temp for each variable argument, with the variable
arguments as fields.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.from_cli">
<em class="property">classmethod </em><code class="descname">from_cli</code><span class="sig-paren">(</span><em>opts</em>, <em>likelihood_evaluator</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.from_cli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.from_cli" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance of this sampler from the given command-line
options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>opts</strong> : ArgumentParser options</p>
<blockquote>
<div><p>The options to parse.</p>
</div></blockquote>
<p><strong>likelihood_evaluator</strong> : LikelihoodEvaluator</p>
<blockquote>
<div><p>The likelihood evaluator to use with the sampler.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">EmceePTSampler</p>
<blockquote class="last">
<div><p>An emcee sampler initialized based on the given arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.likelihood_stats">
<code class="descname">likelihood_stats</code><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.likelihood_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the log likelihood ratio and log prior as a FieldArray.
The returned array has shape ntemps x nwalkers x niterations.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.lnpost">
<code class="descname">lnpost</code><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.lnpost" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the natural logarithm of the likelihood + the prior as an
ntemps x nwalkers x niterations array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.name">
<code class="descname">name</code><em class="property"> = 'emcee_pt'</em><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.ntemps">
<code class="descname">ntemps</code><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.ntemps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.read_acceptance_fraction">
<em class="property">static </em><code class="descname">read_acceptance_fraction</code><span class="sig-paren">(</span><em>fp</em>, <em>temps=None</em>, <em>walkers=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.read_acceptance_fraction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.read_acceptance_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the acceptance fraction from the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the samples from.</p>
</div></blockquote>
<p><strong>temps</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>The temperature index (or a list of indices) to retrieve. If None,
acfs from all temperatures and all walkers will be retrieved.</p>
</div></blockquote>
<p><strong>walkers</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>The walker index (or a list of indices) to retrieve. If None,
samples from all walkers will be obtained.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array</p>
<blockquote class="last">
<div><p>Array of acceptance fractions with shape (requested temps,
requested walkers).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.read_acls">
<em class="property">static </em><code class="descname">read_acls</code><span class="sig-paren">(</span><em>fp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.read_acls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.read_acls" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the acls of all the walker chains saved in the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the acls from.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">WaveformArray</p>
<blockquote class="last">
<div><p>An ntemps x nwalkers <cite>WaveformArray</cite> containing the acls for
every temp and walker, with the variable arguments as fields.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.read_likelihood_stats">
<em class="property">classmethod </em><code class="descname">read_likelihood_stats</code><span class="sig-paren">(</span><em>fp</em>, <em>thin_start=None</em>, <em>thin_interval=None</em>, <em>thin_end=None</em>, <em>iteration=None</em>, <em>temps=None</em>, <em>walkers=None</em>, <em>flatten=True</em>, <em>stats_group=None</em>, <em>array_class=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.read_likelihood_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.read_likelihood_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the likelihood stats from the given file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the stats from.</p>
</div></blockquote>
<p><strong>thin_start</strong> : int</p>
<blockquote>
<div><p>Index of the sample to begin returning stats. Default is to read
stats after burn in. To start from the beginning set thin_start
to 0.</p>
</div></blockquote>
<p><strong>thin_interval</strong> : int</p>
<blockquote>
<div><p>Interval to accept every i-th sample. Default is to use the
<cite>fp.acl</cite>. If <cite>fp.acl</cite> is not set, then use all stats
(set thin_interval to 1).</p>
</div></blockquote>
<p><strong>thin_end</strong> : int</p>
<blockquote>
<div><p>Index of the last sample to read. If not given then
<cite>fp.niterations</cite> is used.</p>
</div></blockquote>
<p><strong>iteration</strong> : int</p>
<blockquote>
<div><p>Get a single iteration. If provided, will override the
<cite>thin_{start/interval/end}</cite> arguments.</p>
</div></blockquote>
<p><strong>temps</strong> : {None, (list of) int, &#8216;all&#8217;}</p>
<blockquote>
<div><p>The temperature index (or list of indices) to retrieve. If None,
only samples from the coldest (= 0) temperature chain will be
retrieved. To retrieve all temperates pass &#8216;all&#8217;, or a list of
all of the temperatures.</p>
</div></blockquote>
<p><strong>walkers</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>The walker index (or a list of indices) to retrieve. If None,
stats from all walkers will be obtained.</p>
</div></blockquote>
<p><strong>flatten</strong> : {True, bool}</p>
<blockquote>
<div><p>The returned array will be one dimensional, with all desired
stats from all desired walkers concatenated together. If False,
the returned array will have dimension requested temps x requested
walkers x requested iterations.</p>
</div></blockquote>
<p><strong>stats_group</strong> : {None, str}</p>
<blockquote>
<div><p>The group in <cite>fp</cite> from which to retrieve the stats. If
None, searches in <cite>fp.stats_group</cite>.</p>
</div></blockquote>
<p><strong>array_class</strong> : {None, array class}</p>
<blockquote>
<div><p>The type of array to return. The class must have a <cite>from_kwargs</cite>
class method. If None, will return a FieldArray.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array_class</p>
<blockquote class="last">
<div><p>The likelihood stats, as an instance of the given
<cite>array_class</cite> (<cite>FieldArray</cite> if <cite>array_class</cite> is None).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.read_samples">
<em class="property">classmethod </em><code class="descname">read_samples</code><span class="sig-paren">(</span><em>fp</em>, <em>parameters</em>, <em>thin_start=None</em>, <em>thin_interval=None</em>, <em>thin_end=None</em>, <em>iteration=None</em>, <em>temps=0</em>, <em>walkers=None</em>, <em>flatten=True</em>, <em>samples_group=None</em>, <em>array_class=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.read_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.read_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads samples for the given parameter(s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to read the samples from.</p>
</div></blockquote>
<p><strong>parameters</strong> : (list of) strings</p>
<blockquote>
<div><p>The parameter(s) to retrieve. A parameter can be the name of any
field in <cite>fp[fp.samples_group]</cite>, a virtual field or method of
<cite>WaveformArray</cite> (as long as the file contains the necessary fields
to derive the virtual field or method), and/or a function of
these.</p>
</div></blockquote>
<p><strong>thin_start</strong> : int</p>
<blockquote>
<div><p>Index of the sample to begin returning samples. Default is to read
samples after burn in. To start from the beginning set thin_start
to 0.</p>
</div></blockquote>
<p><strong>thin_interval</strong> : int</p>
<blockquote>
<div><p>Interval to accept every i-th sample. Default is to use the
<cite>fp.acl</cite>. If <cite>fp.acl</cite> is not set, then use all samples
(set thin_interval to 1).</p>
</div></blockquote>
<p><strong>thin_end</strong> : int</p>
<blockquote>
<div><p>Index of the last sample to read. If not given then
<cite>fp.niterations</cite> is used.</p>
</div></blockquote>
<p><strong>iteration</strong> : int</p>
<blockquote>
<div><p>Get a single iteration. If provided, will override the
<cite>thin_{start/interval/end}</cite> arguments.</p>
</div></blockquote>
<p><strong>walkers</strong> : {None, (list of) int}</p>
<blockquote>
<div><p>The walker index (or a list of indices) to retrieve. If None,
samples from all walkers will be obtained.</p>
</div></blockquote>
<p><strong>temps</strong> : {None, (list of) int, &#8216;all&#8217;}</p>
<blockquote>
<div><p>The temperature index (or list of indices) to retrieve. If None,
only samples from the coldest (= 0) temperature chain will be
retrieved. To retrieve all temperates pass &#8216;all&#8217;, or a list of
all of the temperatures.</p>
</div></blockquote>
<p><strong>flatten</strong> : {True, bool}</p>
<blockquote>
<div><p>The returned array will be one dimensional, with all desired
samples from all desired walkers concatenated together. If False,
the returned array will have dimension requested temps x requested
walkers x requested iterations.</p>
</div></blockquote>
<p><strong>samples_group</strong> : {None, str}</p>
<blockquote>
<div><p>The group in <cite>fp</cite> from which to retrieve the parameter fields. If
None, searches in <cite>fp.samples_group</cite>.</p>
</div></blockquote>
<p><strong>array_class</strong> : {None, array class}</p>
<blockquote>
<div><p>The type of array to return. The class must have a <cite>from_kwargs</cite>
class method and a <cite>parse_parameters</cite> method. If None, will return
a WaveformArray.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">array_class</p>
<blockquote class="last">
<div><p>Samples for the given parameters, as an instance of a the given
<cite>array_class</cite> (<cite>WaveformArray</cite> if <cite>array_class</cite> is None).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>niterations</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the ensemble for a number of samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>niterations</strong> : int</p>
<blockquote>
<div><p>Number of samples to get from sampler.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : numpy.array</p>
<blockquote>
<div><p>An array of current walker positions with shape (nwalkers, ndim).</p>
</div></blockquote>
<p><strong>lnpost</strong> : numpy.array</p>
<blockquote>
<div><p>The list of log posterior probabilities for the walkers at
positions p, with shape (nwalkers, ndim).</p>
</div></blockquote>
<p>rstate :</p>
<blockquote class="last">
<div><p>The current state of the random number generator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.set_p0">
<code class="descname">set_p0</code><span class="sig-paren">(</span><em>prior_distributions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.set_p0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.set_p0" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the initial position of the walkers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>prior_distributions</strong> : list</p>
<blockquote>
<div><p>A list of priors to retrieve random values from (the sort of
thing returned by <cite>prior.read_distributions_from_config</cite>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p0</strong> : array</p>
<blockquote class="last">
<div><p>An ntemps x nwalkers x ndim array of the initial positions that
were set.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.write_acceptance_fraction">
<code class="descname">write_acceptance_fraction</code><span class="sig-paren">(</span><em>fp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.write_acceptance_fraction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.write_acceptance_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Write acceptance_fraction data to file. Results are written to
<cite>fp[acceptance_fraction/temp{k}]</cite> where k is the temperature.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote class="last">
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.write_acls">
<em class="property">static </em><code class="descname">write_acls</code><span class="sig-paren">(</span><em>fp</em>, <em>acls</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.write_acls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.write_acls" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the given autocorrelation lengths to the given file. The acl
of each walker at each temperature and each parameter is saved to
<cite>fp[fp.samples_group/{param}/temp{k}/walker{i}].attrs[&#8216;acl&#8217;]</cite>; the
maximum over all the walkers for a given temperature and param is
saved to <cite>fp[fp.samples_group/{param}/temp{k}].attrs[&#8216;acl&#8217;]</cite>; the
maximum over all of the temperatures and walkers is saved to
<cite>fp[fp.samples_group/{param}].attrs[&#8216;acl&#8217;]</cite>; the maximum over all the
parameters, temperatures, and walkers is saved to the file&#8217;s &#8216;acl&#8217;
attribute.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>An open file handler to write the samples to.</p>
</div></blockquote>
<p><strong>acls</strong> : WaveformArray</p>
<blockquote>
<div><p>An array of autocorrelation lengths (the sort of thing returned by
<cite>compute_acls</cite>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">acl</p>
<blockquote class="last">
<div><p>The maximum of the acls that was written to the file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.write_chain">
<code class="descname">write_chain</code><span class="sig-paren">(</span><em>fp</em>, <em>start_iteration=0</em>, <em>end_iteration=None</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.write_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.write_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the samples from the current chain to the given file. Results
are written to: <cite>fp[fp.samples_group/{vararg}/temp{k}/walker{i}]</cite>,
where <cite>{vararg}</cite> is the name of a variable arg, <cite>{k}</cite> is a temperature
index (smaller = colder), and <cite>{i}</cite> is the index of a walker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
<p><strong>start_iteration</strong> : {0, int}</p>
<blockquote>
<div><p>Write results starting from the given iteration.</p>
</div></blockquote>
<p><strong>end_iteration</strong> : {None, int}</p>
<blockquote>
<div><p>Write results up to the given iteration.</p>
</div></blockquote>
<p><strong>max_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>If samples have not previously been written to the file, a new
dataset will be created. By default, the size of this dataset will
be whatever the length of the sampler&#8217;s chain is at this point. If
you intend to run more iterations, set this value to that size so
that the array in the file will be large enough to accomodate
future data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.write_likelihood_stats">
<code class="descname">write_likelihood_stats</code><span class="sig-paren">(</span><em>fp</em>, <em>start_iteration=0</em>, <em>end_iteration=None</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.write_likelihood_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.write_likelihood_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the given likelihood array to the given file. Results are
written to: <cite>fp[fp.stats_group/{field}/temp{k}/walker{i}]</cite>, where
<cite>{field}</cite> is the name of stat (<cite>loglr</cite>, <cite>prior</cite>), <cite>{k}</cite> is a
temperature index (smaller = colder) and <cite>{i}</cite> is the index of a
walker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
<p><strong>start_iteration</strong> : {0, int}</p>
<blockquote>
<div><p>Write results starting from the given iteration.</p>
</div></blockquote>
<p><strong>end_iteration</strong> : {None, int}</p>
<blockquote>
<div><p>Write results up to the given iteration.</p>
</div></blockquote>
<p><strong>max_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>See <cite>write_chain</cite> for details.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.write_metadata">
<code class="descname">write_metadata</code><span class="sig-paren">(</span><em>fp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.write_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.write_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes metadata about this sampler to the given file. Metadata is
written to the file&#8217;s <cite>attrs</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote class="last">
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_emcee.EmceePTSampler.write_results">
<code class="descname">write_results</code><span class="sig-paren">(</span><em>fp</em>, <em>start_iteration=0</em>, <em>end_iteration=None</em>, <em>max_iterations=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_emcee.html#EmceePTSampler.write_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_emcee.EmceePTSampler.write_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes metadata, samples, likelihood stats, and acceptance fraction
to the given file. See the write function for each of those for
details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fp</strong> : InferenceFile</p>
<blockquote>
<div><p>A file handler to an open inference file.</p>
</div></blockquote>
<p><strong>start_iteration</strong> : {0, int}</p>
<blockquote>
<div><p>Write results starting from the given iteration.</p>
</div></blockquote>
<p><strong>end_iteration</strong> : {None, int}</p>
<blockquote>
<div><p>Write results up to the given iteration.</p>
</div></blockquote>
<p><strong>max_iterations</strong> : {None, int}</p>
<blockquote class="last">
<div><p>If results have not previously been written to the
file, new datasets will be created. By default, the size of these
datasets will be whatever the length of the sampler&#8217;s chain is at
this point. If you intend to run more iterations in the future,
set this value to that size so that the array in the file will be
large enough to accomodate future data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference.sampler_kombine">
<span id="pycbc-inference-sampler-kombine-module"></span><h2>pycbc.inference.sampler_kombine module<a class="headerlink" href="#module-pycbc.inference.sampler_kombine" title="Permalink to this headline">¶</a></h2>
<p>This modules provides classes and functions for using the kombine sampler
packages for parameter estimation.</p>
<dl class="class">
<dt id="pycbc.inference.sampler_kombine.KombineSampler">
<em class="property">class </em><code class="descclassname">pycbc.inference.sampler_kombine.</code><code class="descname">KombineSampler</code><span class="sig-paren">(</span><em>likelihood_evaluator</em>, <em>nwalkers</em>, <em>transd=False</em>, <em>processes=None</em>, <em>min_burn_in=None</em>, <em>update_interval=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_kombine.html#KombineSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_kombine.KombineSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pycbc.inference.sampler_base.BaseMCMCSampler" title="pycbc.inference.sampler_base.BaseMCMCSampler"><code class="xref py py-class docutils literal"><span class="pre">pycbc.inference.sampler_base.BaseMCMCSampler</span></code></a></p>
<p>This class is used to construct the MCMC sampler from the kombine
package.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>likelihood_evaluator</strong> : likelihood class</p>
<blockquote>
<div><p>An instance of the likelihood class from the
pycbc.inference.likelihood module.</p>
</div></blockquote>
<p><strong>nwalkers</strong> : int</p>
<blockquote>
<div><p>Number of walkers to use in sampler.</p>
</div></blockquote>
<p><strong>transd</strong> : bool</p>
<blockquote>
<div><p>If True, the sampler will operate across parameter spaces using a
kombine.clustered_kde.TransdimensionalKDE proposal distribution. In
this mode a masked array with samples in each of the possible sets of
dimensions must be given for the initial ensemble distribution.</p>
</div></blockquote>
<p><strong>processes</strong> : {None, int}</p>
<blockquote>
<div><p>Number of processes to use with multiprocessing. If None, all available
cores are used.</p>
</div></blockquote>
<p><strong>min_burn_in</strong> : {None, int}</p>
<blockquote>
<div><p>Set the minimum number of burn in iterations to use. If None,
<cite>burn_in_iterations</cite> will be initialized to <cite>0</cite>.</p>
</div></blockquote>
<p><strong>update_interval</strong> : {None, int}</p>
<blockquote class="last">
<div><p>Make the sampler update the proposal densities every <cite>update_interval</cite>
iterations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycbc.inference.sampler_kombine.KombineSampler.burn_in">
<code class="descname">burn_in</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_kombine.html#KombineSampler.burn_in"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_kombine.KombineSampler.burn_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Use kombine&#8217;s <cite>burnin</cite> routine to advance the sampler.</p>
<p>If a minimum number of burn-in iterations was specified, this will run
the burn-in until it has advanced at least as many steps as desired.
The initial positions (p0) must be set prior to running.</p>
<p>For more details, see <cite>kombine.sampler.burnin</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : numpy.array</p>
<blockquote>
<div><p>An array of current walker positions with shape (nwalkers, ndim).</p>
</div></blockquote>
<p><strong>lnpost</strong> : numpy.array</p>
<blockquote>
<div><p>The list of log posterior probabilities for the walkers at
positions p, with shape (nwalkers, ndim).</p>
</div></blockquote>
<p><strong>lnprop</strong> : numpy.array</p>
<blockquote class="last">
<div><p>The list of log proposal densities for the walkers at positions p,
with shape (nwalkers, ndim).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_kombine.KombineSampler.chain">
<code class="descname">chain</code><a class="headerlink" href="#pycbc.inference.sampler_kombine.KombineSampler.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all past samples as an nwalker x niterations x ndim array.</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_kombine.KombineSampler.clear_chain">
<code class="descname">clear_chain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_kombine.html#KombineSampler.clear_chain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_kombine.KombineSampler.clear_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the chain and blobs from memory.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pycbc.inference.sampler_kombine.KombineSampler.from_cli">
<em class="property">classmethod </em><code class="descname">from_cli</code><span class="sig-paren">(</span><em>opts</em>, <em>likelihood_evaluator</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_kombine.html#KombineSampler.from_cli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_kombine.KombineSampler.from_cli" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance of this sampler from the given command-line
options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>opts</strong> : ArgumentParser options</p>
<blockquote>
<div><p>The options to parse.</p>
</div></blockquote>
<p><strong>likelihood_evaluator</strong> : LikelihoodEvaluator</p>
<blockquote>
<div><p>The likelihood evaluator to use with the sampler.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">KombineSampler</p>
<blockquote class="last">
<div><p>A kombine sampler initialized based on the given arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_kombine.KombineSampler.lnpost">
<code class="descname">lnpost</code><a class="headerlink" href="#pycbc.inference.sampler_kombine.KombineSampler.lnpost" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the natural logarithm of the likelihood as an
nwalkers x niterations array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pycbc.inference.sampler_kombine.KombineSampler.name">
<code class="descname">name</code><em class="property"> = 'kombine'</em><a class="headerlink" href="#pycbc.inference.sampler_kombine.KombineSampler.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.inference.sampler_kombine.KombineSampler.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>niterations</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/inference/sampler_kombine.html#KombineSampler.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.inference.sampler_kombine.KombineSampler.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the sampler for a number of samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>niterations</strong> : int</p>
<blockquote>
<div><p>Number of samples to get from sampler.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : numpy.array</p>
<blockquote>
<div><p>An array of current walker positions with shape (nwalkers, ndim).</p>
</div></blockquote>
<p><strong>lnpost</strong> : numpy.array</p>
<blockquote>
<div><p>The list of log posterior probabilities for the walkers at
positions p, with shape (nwalkers, ndim).</p>
</div></blockquote>
<p><strong>lnprop</strong> : numpy.array</p>
<blockquote class="last">
<div><p>The list of log proposal densities for the walkers at positions p,
with shape (nwalkers, ndim).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycbc.inference">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pycbc.inference" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pycbc.inject.html" class="btn btn-neutral float-right" title="pycbc.inject package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pycbc.filter.html" class="btn btn-neutral" title="pycbc.filter package" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Alexander Nitz.
      Last updated on Jan 03, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0c81ee',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>